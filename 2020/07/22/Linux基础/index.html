<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">

	
			    <title>
    JerryRain
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="JR">

    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/kobe.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/love.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<link rel="stylesheet" href="/css/mouse.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    
        <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Go on</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/BLOG/">BLOG</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/CODING/">CODING</a></li><li><a class="category-link" href="/categories/FRENCH/">FRENCH</a></li><li><a class="category-link" href="/categories/French/">French</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/Markdown/">Markdown</a></li><li><a class="category-link" href="/categories/ROS/">ROS</a></li><li><a class="category-link" href="/categories/SLAM/">SLAM</a></li><li><a class="category-link" href="/categories/algorithm/">algorithm</a></li><li><a class="category-link" href="/categories/blog/">blog</a></li><li><a class="category-link" href="/categories/git/">git</a></li><li><a class="category-link" href="/categories/latex/">latex</a></li><li><a class="category-link" href="/categories/leetcode/">leetcode</a></li><li><a class="category-link" href="/categories/python/">python</a></li><li><a class="category-link" href="/categories/robot/">robot</a></li><li><a class="category-link" href="/categories/ros/">ros</a></li><li><a class="category-link" href="/categories/ubuntu/">ubuntu</a></li><li><a class="category-link" href="/categories/vim/">vim</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">归档</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2020/10/">October 2020</a></li><li><a class="archive-link" href="/archives/2020/09/">September 2020</a></li><li><a class="archive-link" href="/archives/2020/08/">August 2020</a></li><li><a class="archive-link" href="/archives/2020/07/">July 2020</a></li><li><a class="archive-link" href="/archives/2019/07/">July 2019</a></li><li><a class="archive-link" href="/archives/2019/06/">June 2019</a></li><li><a class="archive-link" href="/archives/2019/05/">May 2019</a></li><li><a class="archive-link" href="/archives/2019/04/">April 2019</a>
	                    </li></ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="https://space.bilibili.com/382551824" title="bilibili">
		                bilibili
		            </a>
		        </li>
		        
		        <li>
		            <a href="https://mmbiz.qpic.cn/mmbiz_jpg/kUwqNZFd4gFa78dbwtX0zRHo4v5SB1J0z7OV0f0rZ7RH8DACRpAJsfV81uUW54pAm1IuianYkDvXmE5s4otAwicg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" title="公众号">
		                公众号
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/JerryRain?tab=repositories" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://v.qq.com/x/page/p0753p3sozo.html" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(http://www.linuxidc.com/upload/2017_04/170401215748251.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Linux 基础</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p></p><h3 style="text-align:center">Linux 基础</h3><br>
1.什么是Linux<p></p>
<p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p>2.Linux和Unix有什么区别</p>
<p>Linux和Unix都是功能强大的操作系统，都是广泛应用的服务器操作系统，两者有很多相似之处，但是两者并非完全相同， 一下是两者的区别：</p>
<ul>
<li>
<p>开源性<br>
Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</p>
</li>
<li>
<p>跨平台性<br>
Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。</p>
</li>
<li>
<p>可视化界面<br>
Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。</p>
</li>
<li>
<p>硬件环境<br>
Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。</p>
</li>
<li>
<p>用户群体<br>
Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。<br>
相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用</p>
</li>
</ul>
<p>3.什么是Linux内核</p>
<p>Linux系统的核心是内核，内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p>
<ul>
<li>系统内存管理</li>
<li>应用程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ul>
<p>4.Linux基本组件是什么</p>
<p>Linux组件：内核，shell，GUI和系统应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</p>
<p>5.Linux体系结构</p>
<p><img src="https://img-blog.csdnimg.cn/20200229173922281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>用户空间（User Space）：用户空间包括用户的应用程序（User Applications）、C库（C Library）。</li>
<li>内核空间（Kernel Space）：内核空间包括系统调用接口（System Call Interface）、内核（Kernel）、平台架构相关的代码（Aarchitecture-Dependent Kernel Code）。</li>
</ul>
<p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p>
<ul>
<li>现代CPU实现了不同的工作模式，不同模式下CPU可以执行的指令和访问的寄存器不同</li>
<li>Linux从CPU的角度出发，为了保护内核安全，把系统分成了两部分</li>
</ul>
<p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成用户空间到内核空间的转移：</p>
<ul>
<li>
<p>系统调用</p>
</li>
<li>
<p>硬件中断</p>
</li>
</ul>
<p>6.BASH和DOS之间的基本区别是什么</p>
<p>BASH和DOS控制台之间的主要区别在于3个方面：</p>
<ul>
<li>BASH命令区分大小写，而DOS命令不区分大小写</li>
<li>在BASH下，/character是目录分隔符，\作为转义字符。在DOS下，\作为命令参数分隔符，\是目录分隔符</li>
<li>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，拓展名为3个字符。BASH没有遵循这样的惯例</li>
</ul>
<p>7.Linux开机</p>
<ul>
<li>主机加电自检，加载BIOS硬件信息</li>
<li>读取MBR的引导文件（GRUB、LILO）</li>
<li>引导Linux内核</li>
<li>运行第一个进程init（进程号永远为1）</li>
<li>进行相应的运行级别</li>
<li>运行终端，输入用户名和密码</li>
</ul>
<p>8.Linux系统缺省的运行级别</p>
<ul>
<li>关机</li>
<li>单机用户模式</li>
<li>字符界面的多用户模式（不支持网络）</li>
<li>未分配使用</li>
<li>图形界面的多用户模式</li>
<li>重启</li>
</ul>
<p>9.Linux使用的进程间通信方式</p>
<ul>
<li>管道（pipe）、流管道（s_pipe）、有名管道（FIFO）</li>
<li>信号（signal）</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>套接字（socket）</li>
</ul>
<p>10.Linux的系统日志文件有哪些</p>
<p>比较重要的是<code>/var/log/messages</code>日志文件，该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图成功或成功的侵入。</p>
<p>11.什么是交换空间</p>
<p>交换空间是Linux使用的一定空间，用于临时保存一些并行开发的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p>
<p>12.什么是root账户</p>
<p>root账户就像一个系统管理员账户，允许完全控制系统，可以在系统创建和维护用户账户，为每个账户分配不同的权限，每次安装Linux时都是默认账户。</p>
<p>13.什么是LILO</p>
<p>LILO是Linux的引导加载程序，它主要用于将Linux操作系统加载到主内存，以便可以开始运行。</p>
<p>14.什么是BASH</p>
<p>BASH是Bourne Again SHell的缩写，它结合了原始版本的Bourne Shel的所有功能以及其他功能，使其更容易使用，它已被改编为运行Linux的大多数系统的默认shell。</p>
<p>15.什么是CIL</p>
<p>CIL全称为 command-line interface，意为命令行界面，在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行，也有人称之为字符用户界面（CUI）。</p>
<p>16.什么是GUI</p>
<p>Graphical User Interface，简称GUI，称为图形用户界面或图形用户接口，是指采用图形方式显示的计算机操作用户界面。</p>
<p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其他一些日常任务。</p>
<p>17.开源的优势是什么</p>
<p>开源允许将软件（包括源代码）免费分享分发给任何感兴趣的人，开发者可以添加功能，甚至可以调试和更正源代码中的错误，以及不断优化更新，然后再次自由地重新分配这些增强的源代码，使社区中的每个人收益。</p>
<p>18.GNU项目的重要性是什么</p>
<p>这种自由软件运动具有多种优势，可以自由地运行程序以及根据需要自由学习和修改</p>
<p>19.Linux系统文件</p>
<p>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</p>
<p>在Linux系统中：<strong>一切都是文件</strong>。在Unix系统中，把一切资源都看作是文件，包括硬件设备，Unix系统把每个硬件都看成是一个文件，通常称为设备文件，用户可以用读写文件的方式实现对硬件的访问。</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">事例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通文件</td>
<td style="text-align:center">用来在辅助存储设备（如磁盘）上存储信息和数据</td>
<td style="text-align:center">包含程序源代码（用C、C++、Java等语言编写）、可执行程序、图片、声音、图像等</td>
</tr>
<tr>
<td style="text-align:center">目录文件</td>
<td style="text-align:center">用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名</td>
<td style="text-align:center">/root、/home</td>
</tr>
<tr>
<td style="text-align:center">链接文件</td>
<td style="text-align:center">用于不同目录下文件的共享</td>
<td style="text-align:center">当创建一个已存在已存在的符号链接时，系统就创建一个链接文件，这个链接文件指向已存在的文件</td>
</tr>
<tr>
<td style="text-align:center">设备文件</td>
<td style="text-align:center">用来访问硬件设备</td>
<td style="text-align:center">包括键盘、硬盘、光驱、打印机等</td>
</tr>
<tr>
<td style="text-align:center">命名管道（FIFO）</td>
<td style="text-align:center">一种特殊类型文件，Linux系统下进程间通信可以通过该文件完成</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>20.Linux文件系统结构</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYzIuaW9jb2Rlci5jbi81YzJmNTRmMjhkNGVhYmJlMTM4ZmQ4Y2JiNzYzYTFmMQ?x-oss-process=image/format,png" alt></p>
<p>目录说明：</p>
<blockquote>
<p>/bin：存放二进制可执行文件（ls,cat,mkdir等），常用命令一般都在这里</p>
<p>/etc：存放系统几点，比如管理和配置文件</p>
<p>/home：存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user</p>
<p>/usr：用于存放系统应用程序</p>
<p>/opt：额外安装的可选应用程序包所放置的位置，一般情况下，可以把tomcat等安装到这里</p>
<p>/proc：虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息</p>
<p>/root：超级用户（系统管理员）的主目录（特权阶级o）</p>
<p>/sbin：存放二进制可执行文件，只有root才能访问，这里存放的是系统管理员使用的系统级别的管理命令和程序，如ifconfig</p>
<p>/dev：用于存放设备文件</p>
<p>/mnt：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统</p>
<p>/boot：存放用于系统引导时使用的各种文件</p>
<p>/lib：存放和系统运行相关的库文件</p>
<p>/tmp：用于存放各种临时文件，，是公用的临时文件存储点</p>
<p>/var：用于存放运行时需要改变数据的文件，也是某些大型文件的溢出区，比方说各种服务的日志文件（系统启动日志等）</p>
<p>/lost+found：这个目录平时是空的，系统非正常关机而留下临时未保存的文件</p>
</blockquote>
<p>21.什么是inode</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区“（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘时，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&quot;块&quot;（block）。这种由多个扇区组成的”块“，是文件存取的最小单位。”块“的大小，最常见的是4KB，即连续八个sector组成一个block。</p>
<p>文件数据都储存在”块“中，所以还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等。这种存储文件元信息的区域叫做inode，中文译名为”索引节点“。每一个文件都有对应的inode，里面包含与该文件相关的一些信息。</p>
<p>Linux通过inode节点表将文件的逻辑结构和物理结构进行转换。</p>
<ul>
<li>inode节点是一个64字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在inode节点表中最重要的内容是磁盘地址表，在磁盘地址表中有13个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>
<li>Linux文件系统通过把inode节点和节点名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的inode节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li>
</ul>
<p>22.什么是硬链接和软链接</p>
<p>（1）硬链接</p>
<p>由于Linux下的文件是通过索引节点（inode）来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配inode。每添加一个硬链接，文件的链接数就加1。</p>
<p>不足：</p>
<ul>
<li>不可以在不同文件系统的文件间建立链接</li>
<li>只有超级用户才可以为目录创建硬链接</li>
</ul>
<p>（2）软链接</p>
<p>软链接客服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接，因而现在更为广泛使用，具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>
<p>不足：</p>
<ul>
<li>因为链接文件包含原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，可以随意移动；还有要系统分配额外的空间用于建立新的索引节点和保存原文件的路径</li>
</ul>
<p>实际场景下，基本是使用软链接。硬链接和软链接区别如下：</p>
<ul>
<li>硬链接不可以分区，软链接可以跨分区</li>
<li>硬链接指向一个inode节点，而软链接则是创建一个新的inode节点</li>
<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除</li>
</ul>
<p>23.什么是RAID</p>
<p>RAID全称为独立磁盘冗余阵列（Redundant Array of Independent Disks），基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。RAID通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当成一个硬盘。</p>
<p>RAID分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据实际需求选择不同的RAID方案。</p>
<p>24.一台Linux系统初始化环境后需要做哪些安全工作？</p>
<p>(1)添加普通用户登录，禁止root用户登录，更改SSH端口号。</p>
<p>(2)服务器使用密钥登录，禁止密码登录</p>
<p>(3)开启防火墙，关闭SElinux，根据业务需求设置相应的防火墙规则</p>
<p>(4)装fail2ban这种防止SSH暴力破击的软件</p>
<p>(5)设置只允许公司办公网出口IP能登陆服务器</p>
<p>(6)修改历史命令记录的条数为10条</p>
<p>(7)只允许有需要的服务器可以访问外网，其他全部禁止</p>
<p>(8)做好软件层面的防护：设置nginx_waf模块防止SQL注入；把Web服务使用www用户启动，更改网站目录的所有者和所属组为www</p>
<p>25.什么是CC攻击和DDOS攻击</p>
<p>攻击，即是通过大量合法的请求占用大量网络资源，以达到网络瘫痪的目的。</p>
<ul>
<li>CC攻击，主要是用来攻击页面的，模拟多个用户不停的对网站页面进行访问，从而使系统资源消耗殆尽</li>
<li>DDOS攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动DDOS攻击</li>
</ul>
<p>怎么预防CC攻击和DDOS攻击：</p>
<p>防CC攻击和DDOS攻击，这些只能用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p>
<p>流量清洗这块，主要是买ISP服务商的防攻击的服务就可以，机房一般有空余流量，一般是买服务，毕竟攻击不会持续长时间。</p>
<p>26.什么是网站数据库注入</p>
<ul>
<li>由于程序员的水平和经验参差不齐，大部分程序员在编写代码时，没有对用户输入数据的合法性进行判断</li>
<li>应用程序存在安全隐患，用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些想得知的数据，这就是SQL注入</li>
<li>SQL注入，是从正常的www端口访问，而且表面看起来跟一般的Web页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵长时间都不会发觉</li>
</ul>
<p>如何过滤和预防：</p>
<p>数据库网页端注入这种，可以考虑使用nginx_waf做过滤和预防。</p>
<p>27.什么是Shell脚本</p>
<p>一个Shell脚本是一个文本文件，包含一个或多个命令。作为系统管理员，经常需要使用多个命令来完成一项任务，可以添加这些所有命令在一个文本文件（shell脚本）来完成这些日常工作任务。</p>
<p>在Linux系统中，<code>/bin/bash</code>是默认登录Shell，是在创建用户时分配的。</p>
<p>使用<code>chsh &lt;用户名&gt; -s &lt;新shell&gt;</code>命令可以改变默认的Shell。</p>
<p>在Shell脚本中，可以使用<code>#</code>来注释每一行，注释可以用来描述一个脚本可以做什么和它是如何工作的。</p>
<p><strong>语法</strong></p>
<p>在Shell脚本中，可以使用两种类型的变量：</p>
<ul>
<li>系统定义变量：系统定义变量由系统自己创建的，这些变量通常用大写字母组成，可以使用<code>set</code>命令查看</li>
<li>用户定义变量：用户定义变量由系统用户来生成和定义，变量的值可以通过命令<code>echo $&lt;变量名&gt;</code>查看</li>
</ul>
<p>在写一个Shell脚本时，如果想要检查前一个命令是否执行成功，在<code>if</code>条件中使用<code>$?</code>可以检查前一命令的结束状态。</p>
<ul>
<li>
<p>如果结束状态是0，说明前一个命令执行成功：</p>
<pre class=" language-language-shell"><code class="language-language-shell">root@localhost:~## ls /usr/bin/shar
/usr/bin/shar
root@localhost:~## echo $?
0
</code></pre>
</li>
<li>
<p>如果结束状态不是0，说明命令执行失败：</p>
<pre class=" language-language-shell"><code class="language-language-shell">root@localhost:~## ls /usr/bin/share
ls: cannot access /usr/bin/share: No such file or directory
root@localhost:~## echo $?
2
</code></pre>
</li>
</ul>
<p>Bourne Shell（bash）有哪些特殊的变量：</p>
<pre><code>内建变量    解释
$0    命令行中的脚本名字
$1    第一个命令行参数
$2    第二个命令行参数
…..    …….
$9    第九个命令行参数
$##    命令行参数的数量
$*    所有命令行参数，以空格隔开
</code></pre>
<p>取消变量或取消变量赋值：</p>
<p><code>unset &lt;变量名&gt;</code>命令用于取消变量或取消变量赋值。</p>
<p>Shell脚本中的if语法的嵌套：</p>
<pre class=" language-language-shell"><code class="language-language-shell">if [ 条件 ]
then
命令1
命令2
…..
else
if [ 条件 ]
then
命令1
命令2
….
else
命令1
命令2
…..
fi
fi
</code></pre>
<p>在Shell脚本中，在<code>if-shen</code>中使用测试命令（<code>-gt</code>等）来比较两个数字：</p>
<pre class=" language-language-shell"><code class="language-language-shell">#!/bin/bash
x=10
y=20
if [ $x -gt $y ]
then
echo “x is greater than y”
else
echo “y is greater than x”
fi
</code></pre>
<p>#!/bin/bash的作用：</p>
<p><code>#!/bin/bash</code> 是 Shell 脚本的第一行，称为释伴（shebang）行。</p>
<ul>
<li>这里 <code>#</code> 符号叫做 hash ，而 <code>!</code> 叫做 bang。</li>
<li>它的意思是命令通过 <code>/bin/bash</code> 来执行。</li>
</ul>
<p>Shell脚本中case语句的语法：</p>
<pre class=" language-language-shell"><code class="language-language-shell">case 变量 in
值1)
命令1
命令2
…..
最后命令
!!
值2)
命令1
命令2
……
最后命令
;;
esac
</code></pre>
<p>Shell脚本中for循环语法：</p>
<pre class=" language-language-shell"><code class="language-language-shell">for 变量 in 循环列表
do
命令1
命令2
….
最后命令
done
</code></pre>
<p>Shell脚本中while循环语法：</p>
<p>如同for循环，while循环只要条件成立就重复它的命令块；</p>
<p>不同于for循环，while循环会不断迭代，直到它的条件不为真。</p>
<p>while循环基础语法：</p>
<pre class=" language-language-shell"><code class="language-language-shell">while [ 条件 ]
do
命令…
done
</code></pre>
<p>do-while语句类似于while语句，但检查条件语句之前先执行命令。</p>
<p>do-while语句的基本格式：</p>
<pre class=" language-language-shell"><code class="language-language-shell">do
{
命令
} while (条件)
</code></pre>
<p>Shell脚本中break命令的作用：</p>
<p><code>break</code>命令一个简单的用途就是退出执行中的循环，可以在while和until循环中使用break命令跳出循环。</p>
<p>Shell脚本中continue命令的作用：</p>
<p>continue命令不同于break命令，它只跳出当前循环的迭代，而不是整个循环。continue命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p>
<p>在Shell脚本如何定义函数：</p>
<p>函数是拥有名字的代码块，当定义代码块，可以在我们的脚本调用函数名字，该块就会被执行。</p>
<pre class=" language-language-shell"><code class="language-language-shell">$ diskusage () { df -h ; }

[ function ] 函数名 [()]
{
命令;
[return int;]
}
</code></pre>
<p>如何让Shell脚本得到来自终端的输入：</p>
<pre class=" language-language-shell"><code class="language-language-shell">## vi /tmp/test.sh
#!/bin/bash
echo ‘Please enter your name’
read name
echo “My Name is $name”
## ./test.sh
Please enter your name
ThinkWon
My Name is ThinkWon
</code></pre>
<p>在Shell脚本中，如何执行算数运算：</p>
<ul>
<li>使用expr命令：<code>## expr 5 + 2</code></li>
<li>使用一个美元符号和方括号（<code>$[表达式]</code>）：<code>test = $[16+4]; test=$[16+4]</code></li>
</ul>
<p>执行Shell脚本：</p>
<p>使用chmod命令来使脚本可执行，如<code>chmod a+x script.sh</code>。</p>
<p>如何调试Shell脚本：</p>
<ul>
<li>使用<code>-x</code>可以调试Shell脚本，如<code>sh -x script.sh</code></li>
<li>另一种方法就是使用<code>-nav</code>参数，如<code>sh -nv script.sh</code></li>
</ul>
<p>将标准输出和错误输出同时重定向到同一位置：</p>
<ul>
<li>方法一：<code>2&gt;&amp;1 (如## ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 )</code></li>
<li>方法二：<code>&amp;&gt; (如## ls /usr/share/doc &amp;&gt; out.txt )</code></li>
</ul>
<p>在Shell脚本中，如何测试文件：</p>
<p>test命令可以用来测试文件。</p>
<pre><code>Test         用法
-d 文件名    如果文件存在并且是目录，返回true
-e 文件名    如果文件存在，返回true
-f 文件名    如果文件存在并且是普通文件，返回true
-r 文件名    如果文件存在并可读，返回true
-s 文件名    如果文件存在并且不为空，返回true
-w 文件名    如果文件存在并可写，返回true
-x 文件名    如果文件存在并可执行，返回true
</code></pre>
<p>28.如何选择Linux操作系统版本</p>
<p>一般来说，桌面用户选择Ubuntu，服务器首选RHEL或CentOS，两者中首选CentOS。</p>
<ul>
<li>安全性能要求较高，选择Debian或者FreeBSD</li>
<li>需要使用数据库高级服务和电子邮件网络应用的用户可以选择SUSE</li>
<li>想要新技术新功能可以选择Feddora，Feddora是RHEL和CentOS的一个测试版本和预发布版本</li>
<li><strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</li>
</ul>
<p>29.如何规划一台Linux主机，步骤是怎样？</p>
<p>1、确定机器是做什么用的，比如做Web、DB还是游戏服务器</p>
<p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做</p>
<p>3、需要优化系统的哪些参数，需要创建哪些用户等等</p>
<p>30.哪些因素会导致网站访问慢？</p>
<p>1、服务器出口带宽不够用</p>
<blockquote>
<ul>
<li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>
<li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>
</ul>
</blockquote>
<p>2、服务器过载过大，导致响应不过来</p>
<blockquote>
<p>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。<br>
如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</p>
</blockquote>
<p>3、数据库瓶颈</p>
<blockquote>
<ul>
<li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>
<li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>
</ul>
</blockquote>
<p>4、网站开发代码没有优化好</p>
<blockquote>
<ul>
<li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li>
</ul>
</blockquote>
<p>当用户反馈网站访问慢，应当如何排查？</p>
<p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p>
<p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p>
<p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p>
<p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p>
<p>当用户反馈网站访问慢，应当如何解决？</p>
<p>1、如果是出口带宽问题，那么申请加大出口带宽。<br>
2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。<br>
3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。<br>
4、申请购买 CDN 服务，加载用户的访问。<br>
5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</p>
<h4 id="文件管理命令">文件管理命令</h4>
<p><strong>(1)cat命令</strong></p>
<p>cat命令用于连接文件并打印到标准输出设备上。</p>
<p>cat主要三大功能：</p>
<ul>
<li>
<p>一次显示整个文件</p>
<pre><code>cat filename
</code></pre>
</li>
<li>
<p>从键盘创建一个文件</p>
<pre><code>cat &gt; filename
</code></pre>
<p>只能创建新文件，不能编辑已有文件。</p>
</li>
<li>
<p>将几个文件合并为一个文件</p>
<ul>
<li>-b：非空输出行号</li>
<li>-n：输出所有行号</li>
</ul>
<pre><code>cat file1 file2 &gt; file
</code></pre>
</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p>
<pre><code>cat -n log2012.log log2013.log
</code></pre>
</li>
<li>
<p>把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p>
<pre><code>cat -b log2012.log log2013.log log.log
</code></pre>
</li>
<li>
<p>使用 here doc 生成新文件</p>
<pre><code>cat &gt;log.txt &lt;&lt;EOF
&gt;Hello
&gt;World
&gt;PWD=$(pwd)
&gt;EOF
ls -l log.txt
cat log.txt
Hello
World
PWD=/opt/soft/test
</code></pre>
</li>
<li>
<p>反向列示</p>
<pre><code>tac log.txt
PWD=/opt/soft/test
World
Hello
</code></pre>
</li>
</ul>
<p><strong>(2)chmod命令</strong></p>
<p>Linux/Unix的文件调用权限分为三个等级：文件拥有者、群组、其他。利用chmod可以控制文件如何被他人所调用。</p>
<p>chmod命令可用于改变linux系统文件或目录的访问权限，用它控制文件或目录的访问权限。该命令有两种用法：一种是包含字母和操作符表达式的文字设定法，另一种是包含数字的数字设定法。</p>
<p>每一个文件或目录的访问权限都有三组，每三组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可 使用<code>ls -l test.txt</code>查找。</p>
<p>以文件 log2012.log 为例：</p>
<pre><code>-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
</code></pre>
<p>第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件；如果是d，表示是一个目录。从第二个开始到第十个字符这9个字符，3个字符为一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空允许，r代表只读，w代表写，x代表可执行。</p>
<p>常用参数：</p>
<blockquote>
<p>-c：当发生改变时，报告处理信息</p>
<p>-R：处理指定目录以及其子目录下所有文件</p>
</blockquote>
<p>权限范围：</p>
<blockquote>
<p>u：目录或文件的当前用户</p>
<p>g：目录或文件的当前群组</p>
<p>o：除了目录或者文件的当前用户或群组之外的用户或群组</p>
<p>a：所有的用户及群组</p>
</blockquote>
<p>权限代号：</p>
<blockquote>
<p>r：读权限，用数字4表示</p>
<p>w：写权限，用数字2表示</p>
<p>x：执行权限，用数字1表示</p>
<p>-：删除权限，用数字0表示</p>
<p>s：特殊权限</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>增加文件 t.log 所有用户可执行权限</p>
<pre><code>chmod a+x t.log
</code></pre>
</li>
<li>
<p>撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p>
<pre><code>chmod u=r t.log -c
</code></pre>
</li>
<li>
<p>给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p>
<pre><code>chmod 751 t.log -c
chmod u=rwx,g=rx,o=x t.log -c
</code></pre>
</li>
<li>
<p>将 test 目录及其子目录所有文件添加可读权限</p>
<pre><code>chmod u+r,g+r,o+r -R text/ -c
</code></pre>
</li>
</ul>
<p><strong>(3)chown命令</strong></p>
<p>chown命令将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p>
<p>实例：</p>
<ul>
<li>
<p>改变拥有者和群组并显示改变信息</p>
<pre><code>chown -c mail:mail log2012.log
</code></pre>
</li>
<li>
<p>改变文件群组</p>
<pre><code>chown -c :mail t.log
</code></pre>
</li>
<li>
<p>改变文件夹及子文件目录属主及属组为mail</p>
<pre><code>chown -cR mail: test/
</code></pre>
</li>
</ul>
<p><strong>(4)cp命令</strong></p>
<p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<p>命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖。</p>
<blockquote>
<pre><code>-i 提示
-r 复制目录及目录内所有项目
-a 复制的文件与原文件时间一样
</code></pre>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖</p>
<pre><code>cp -ai a.txt test
</code></pre>
</li>
<li>
<p>为 a.txt 建议一个链接（快捷方式）</p>
<pre><code>cp -s a.txt link_a.txt
</code></pre>
</li>
</ul>
<p><strong>(5)find命令</strong></p>
<p>用于在文件树中查找文件，并作出相应的处理。</p>
<p>命令格式：</p>
<pre><code>find pathname -options [-print -exec -ok ...]
</code></pre>
<p>命令参数：</p>
<blockquote>
<p>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br>
-print： find命令将匹配的文件输出到标准输出。<br>
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {  } ;，注意{   }和\；之间的空格。</p>
<p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。</p>
<p>-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>
</blockquote>
<p>命令选项：</p>
<blockquote>
<p>-name 按照文件名查找文件<br>
-perm 按文件权限查找文件<br>
-user 按文件属主查找文件<br>
-group  按照文件所属的组来查找文件。<br>
-type  查找某一类型的文件，诸如：<br>
b - 块设备文件<br>
d - 目录<br>
c - 字符设备文件<br>
l - 符号链接文件<br>
p - 管道文件<br>
f - 普通文件</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>查找 48 小时内修改过的文件</p>
<pre><code>find -atime -2
</code></pre>
</li>
<li>
<p>在当前目录查找 以 .log 结尾的文件。<br>
<strong>.</strong> 代表当前目录</p>
<pre><code>find ./ -name '*.log'
</code></pre>
</li>
<li>
<p>查找 /opt 目录下 权限为 777 的文件</p>
<pre><code>find /opt -perm 777
</code></pre>
</li>
<li>
<p>查找大于 1K 的文件</p>
<pre><code>find -size +1000c
</code></pre>
</li>
<li>
<p>查找等于 1000 字符的文件</p>
<pre><code>find -size 1000c
</code></pre>
</li>
</ul>
<p><strong>(6)head命令</strong></p>
<p>head用来显示档案的开头至输出标准输出中，默认head命令打印其相应文件的头10行。</p>
<p>常用参数：</p>
<blockquote>
<p>-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示 1.log 文件中前 20 行</p>
<pre><code>head 1.log -n 20
</code></pre>
</li>
<li>
<p>显示 1.log 文件前 20 字节</p>
<pre><code>head -c 20 log2014.log
</code></pre>
</li>
<li>
<p>显示 t.log最后 10 行</p>
<pre><code>head -n -10 t.log
</code></pre>
</li>
</ul>
<p><strong>(7)less命令</strong></p>
<p>less与more类似，使用less指令可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。</p>
<p>常用命令参数：</p>
<blockquote>
<p>-i  忽略搜索时的大小写<br>
-N  显示每行的行号<br>
-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>
-s  显示连续空行为一行<br>
/字符串：向下搜索“字符串”的功能<br>
?字符串：向上搜索“字符串”的功能<br>
n：重复前一个搜索（与 / 或 ? 有关）<br>
N：反向重复前一个搜索（与 / 或 ? 有关）<br>
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格<br>
b  向后翻一页<br>
d  向后翻半页<br>
h  显示帮助界面<br>
Q  退出less 命令<br>
u  向前滚动半页<br>
y  向前滚动一行<br>
空格键 滚动一行<br>
回车键 滚动一页<br>
[pagedown]： 向下翻动一页<br>
[pageup]：   向上翻动一页</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>ps 查看进程信息并通过 less 分页显示</p>
<pre><code>ps -aux | less -N
</code></pre>
</li>
<li>
<p>查看多个文件</p>
<pre><code>less 1.log 2.log
</code></pre>
<p>可以使用n查看下一个，使用p查看前一个</p>
</li>
</ul>
<p><strong>(8)ln命令</strong></p>
<p>ln命令的功能是为文件在另外一个位置建立一个同步链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过ln创建的链接（link）减少磁盘占用量。</p>
<p>常用参数：</p>
<blockquote>
<p>-b 删除，覆盖以前建立的链接</p>
<p>-s 软链接（符号链接）</p>
<p>-v 显示详细处理过程</p>
</blockquote>
<p>注意：</p>
<ul>
<li>ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化。</li>
<li>ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li>
<li>n指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</li>
</ul>
<p>链接分类：软件链接和硬链接</p>
<p>软链接：</p>
<ul>
<li>软链接，以路径的形式存在，类似于Windows操作系统中的快捷方式</li>
<li>软链接可以跨文件系统，硬链接不可以</li>
<li>软链接可以对一个不存在的文件名进行链接</li>
<li>软链接可以对目录进行链接</li>
</ul>
<p>硬链接：</p>
<ul>
<li>硬链接，以文件副本形式存在，但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>给文件创建软链接，并显示操作信息</p>
<pre><code>ln -sv source.log link.log
</code></pre>
</li>
<li>
<p>给文件创建硬链接，并显示操作信息</p>
<pre><code>ln -v source.log link1.log
</code></pre>
</li>
<li>
<p>给目录创建软链接</p>
<pre><code>ln -sv /opt/soft/test/test3 /opt/soft/test/test5
</code></pre>
</li>
</ul>
<p><strong>(9)locate命令</strong></p>
<p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。<br>
locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找。</p>
<p>常用参数：</p>
<blockquote>
<p>-l num（要显示的行数）</p>
<p>-f   将特定的档案系统排除在外，如将proc排除在外</p>
<p>-r   使用正则运算式做为寻找条件</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>查找和 pwd 相关的所有文件(文件名中包含 pwd）</p>
<pre><code>locate pwd
</code></pre>
</li>
<li>
<p>搜索 etc 目录下所有以 sh 开头的文件</p>
<pre><code>locate /etc/sh
</code></pre>
</li>
<li>
<p>查找 /var 目录下，以 reason 结尾的文件</p>
<pre><code>locate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）
</code></pre>
</li>
</ul>
<p><strong>(10)more命令</strong></p>
<p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>
<p>命令参数：</p>
<blockquote>
<p>+n      从笫 n 行开始显示<br>
-n       定义屏幕大小为n行<br>
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示<br>
-c       从顶部清屏，然后显示<br>
-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能<br>
-l        忽略Ctrl+l（换页）字符<br>
-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似<br>
-s       把连续的多个空行显示为一行<br>
-u       把文件内容中的下画线去掉</p>
</blockquote>
<p>常用操作指令：</p>
<blockquote>
<p>Enter    向下 n 行，需要定义。默认为 1 行<br>
Ctrl+F   向下滚动一屏<br>
空格键  向下滚动一屏<br>
Ctrl+B  返回上一屏<br>
=       输出当前行的行号<br>
:f     输出文件名和当前行的行号<br>
V      调用vi编辑器<br>
!命令   调用Shell，并执行命令<br>
q       退出more</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示文件中从第3行起的内容</p>
<pre><code>more +3 text.txt
</code></pre>
</li>
<li>
<p>在所列出文件目录详细信息，借助管道使每次显示 5 行</p>
<pre><code>ls -l | more -5 （按空格显示下 5 行）
</code></pre>
</li>
</ul>
<p><strong>(11)mv命令</strong></p>
<p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p>
<p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p>
<p>实例：</p>
<ul>
<li>
<p>将文件 test.log 重命名为 test1.txt</p>
<pre><code>mv test.log test1.txt
</code></pre>
</li>
<li>
<p>将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p>
<pre><code>mv log1.txt log2.txt log3.txt /test3
</code></pre>
</li>
<li>
<p>将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p>
<pre><code>mv -i log1.txt log2.txt
</code></pre>
</li>
<li>
<p>移动当前文件夹下的所有文件到上一级目录</p>
<pre><code>mv * ../
</code></pre>
</li>
</ul>
<p><strong>(12)rm命令</strong></p>
<p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>
<p>使用指令：</p>
<pre><code>rm [选项] 文件
</code></pre>
<p>实例：</p>
<ul>
<li>
<p>删除任何 .log 文件，删除前逐一询问确认</p>
<pre><code>rm -i *.log
</code></pre>
</li>
<li>
<p>删除 test 子目录及子目录中所有档案删除，并且不用一一确认</p>
<pre><code>rm -rf test
</code></pre>
</li>
<li>
<p>删除以 -f 开头的文件</p>
<pre><code>rm -- -f*
</code></pre>
</li>
</ul>
<p><strong>(13)tail命令</strong></p>
<p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<p>常用参数：</p>
<blockquote>
<p>-f 循环读取（常用于查看递增的日志文件）</p>
<p>-n&lt;行数&gt; 显示行数（从后向前）</p>
</blockquote>
<p><strong>(14)touch命令</strong></p>
<p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<p>语法：</p>
<pre><code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]
</code></pre>
<p>参数说明：</p>
<blockquote>
<p>a 改变档案的读取时间记录。<br>
m 改变档案的修改时间记录。<br>
c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。<br>
f 不使用，是为了与其他 unix 系统的相容性而保留。<br>
r 使用参考档的时间记录，与 --file 的效果一样。<br>
d 设定时间与日期，可以使用各种不同的格式。<br>
t 设定档案的时间记录，格式与 date 指令相同。<br>
–no-create 不会建立新档案。<br>
–help 列出指令格式。<br>
–version 列出版本讯息。</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间</p>
<pre><code>touch testfile                #修改文件的时间属性 
</code></pre>
</li>
<li>
<p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;</p>
<pre><code>touch file            #创建一个名为“file”的新的空白文件 
</code></pre>
</li>
</ul>
<p><strong>(15)vim命令</strong></p>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，被广泛使用。</p>
<ul>
<li>
<p>打开文件并跳到第 10 行：</p>
<pre><code>vim +10 filename.txt
</code></pre>
</li>
<li>
<p>打开文件跳到第一个匹配的行：</p>
<pre><code>vim +/search-term filename.txt
</code></pre>
</li>
<li>
<p>以只读模式打开文件：</p>
<pre><code>vim -R /etc/passwd
</code></pre>
</li>
</ul>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，**输入模式（Insert mode）**和 <strong>底线命令模式（Last line mode）</strong>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNy92aW0tdmktd29ya21vZGVsLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p><strong>(16)whereis命令</strong></p>
<p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p>
<p>常用参数：</p>
<blockquote>
<p>-b   定位可执行文件。</p>
<p>-m   定位帮助文件。</p>
<p>-s   定位源代码文件。</p>
<p>-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>查找 locate 程序相关文件</p>
<pre><code>whereis locate
</code></pre>
</li>
<li>
<p>查找 locate 的源码文件</p>
<pre><code>whereis -s locate
</code></pre>
</li>
<li>
<p>查找 lcoate 的帮助文件</p>
<pre><code>whereis -m locate
</code></pre>
</li>
</ul>
<p><strong>(17)which命令</strong></p>
<p>在 linux 要查找某个文件，但不知道文件目录，可以使用下面的一些命令来搜索：</p>
<pre><code>which     查看可执行文件的位置。
whereis 查看文件的位置。
locate  配合数据库查看文件位置。
find        实际搜寻硬盘查询文件名称。
</code></pre>
<p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>常用参数：</p>
<pre><code>-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
</code></pre>
<p>实例：</p>
<ul>
<li>
<p>查看 ls 命令是否存在，执行哪个</p>
<pre><code>which ls
</code></pre>
</li>
<li>
<p>查看 which</p>
<pre><code>which which
</code></pre>
</li>
<li>
<p>查看 cd</p>
<pre><code>which cd （显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）
</code></pre>
</li>
<li>
<p>查看当前 PATH 配置</p>
<pre><code>echo $PATH
</code></pre>
</li>
</ul>
<h4 id="文档编辑命令">文档编辑命令</h4>
<p>(1) grep命令</p>
<p>强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索。</p>
<p>grep的工作方式：它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串都被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>命令格式：</p>
<pre><code>grep [option] pattern file|dir
</code></pre>
<p>常用参数：</p>
<blockquote>
<p>-A n --after-context显示匹配字符后n行<br>
-B n --before-context显示匹配字符前n行<br>
-C n --context 显示匹配字符前后n行<br>
-c --count 计算符合样式的列数<br>
-i 忽略大小写<br>
-l 只列出文件内容符合指定的样式的文件名称<br>
-f 从文件中读取关键词<br>
-n 显示匹配内容的所在文件中行数<br>
-R 递归查找文件夹</p>
</blockquote>
<p>grep的规则表达式：</p>
<blockquote>
<p>^  #锚定行的开始 如：’^grep’匹配所有以grep开头的行。<br>
$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。<br>
.  #匹配一个非换行符的字符 如：'gr.p’匹配gr后接一个任意字符，然后是p。</p>
<ul>
<li>#匹配零个或多个先前字符 如：‘<em>grep’匹配所有一个或多个空格后紧跟grep的行。<br>
.</em>   #一起用代表任意字符。<br>
[]   #匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。<br>
[^]  #匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。<br>
(…)  #标记匹配字符，如’(love)’，love被标记为1。<br>
&lt;      #锚定单词的开始，如:’&lt;grep’匹配包含以grep开头的单词的行。<br>
&gt;      #锚定单词的结束，如’grep&gt;'匹配包含以grep结尾的单词的行。<br>
x{m}  #重复字符x，m次，如：'0{5}'匹配包含5个o的行。<br>
x{m,}  #重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。<br>
x{m,n}  #重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5–10个o的行。<br>
\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。<br>
\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。<br>
\b    #单词锁定符，如: '\bgrep\b’只匹配grep。</li>
</ul>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>查找指定进程</p>
<pre><code>ps -ef | grep svn
</code></pre>
</li>
<li>
<p>查找指定进程个数</p>
<pre><code>ps -ef | grep svn -c
</code></pre>
</li>
<li>
<p>从文件中读取关键词</p>
<pre><code>cat test1.txt | grep -f key.log
</code></pre>
</li>
<li>
<p>从文件夹中递归查找以grep开头的行，并只列出文件</p>
<pre><code>grep -lR '^grep' /tmp
</code></pre>
</li>
<li>
<p>查找非x开关的行内容</p>
<pre><code>grep '^[^x]' test.txt
</code></pre>
</li>
<li>
<p>显示包含 ed 或者 at 字符的内容行</p>
<pre><code>grep -E 'ed|at' test.txt
</code></pre>
</li>
</ul>
<p>(2) wc命令</p>
<p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出。</p>
<p>命令格式：</p>
<pre><code>wc [option] file
</code></pre>
<p>命令参数：</p>
<blockquote>
<p>-c 统计字节数</p>
<p>-l 统计行数</p>
<p>-m 统计字符数</p>
<p>-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>查找文件的行数、单词数、字节数、文件名</p>
<pre><code>wc test.txt
</code></pre>
<p>结果：</p>
<pre><code>7     8     70     test.txt
</code></pre>
</li>
<li>
<p>统计输出结果的行数</p>
<pre><code>cat test.txt | wc -l
</code></pre>
</li>
</ul>
<h4 id="磁盘管理命令">磁盘管理命令</h4>
<p>(1) cd命令</p>
<p>命令语法：</p>
<pre><code>cd [目录名]
</code></pre>
<p>说明：切换当前目录至dirName</p>
<p>实例：</p>
<ul>
<li>
<p>进入要目录</p>
<pre><code>cd /
</code></pre>
</li>
<li>
<p>进入 “home” 目录</p>
<pre><code>cd ~
</code></pre>
</li>
<li>
<p>进入上一次工作路径</p>
<pre><code>cd -
</code></pre>
</li>
<li>
<p>把上个命令的参数作为cd参数使用</p>
<pre><code>cd !$
</code></pre>
</li>
</ul>
<p>(2) df命令</p>
<p>显示磁盘空间使用情况，获取硬盘被占用多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以1KB为单位进行显示，除非环境变量POSIXLY_CORRECT被指定，那样将以512字节为单位进行显示。</p>
<p>常用参数：</p>
<blockquote>
<p>-a 全部文件系统列表</p>
<p>-h 以方便阅读的方式显示信息</p>
<p>-i 显示inode信息</p>
<p>-k 区块为1024字节</p>
<p>-l 只显示本地磁盘</p>
<p>-T 列出文件系统类型</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示磁盘使用情况</p>
<pre><code>df -l
</code></pre>
</li>
<li>
<p>以易读方式列出所有文件系统及其类型</p>
<pre><code>df -haT
</code></pre>
</li>
</ul>
<p>(3) du命令</p>
<p>du命令是查看使用空间，但是与du命令不同的是linux du 命令是对文件和目录磁盘使用的空间的查看。</p>
<p>命令格式：</p>
<pre><code>du [选项] [文件]
</code></pre>
<p>常用参数：</p>
<blockquote>
<p>-a 显示目录中所有文件大小</p>
<p>-k 以KB为单位显示文件大小</p>
<p>-m 以MB为单位显示文件大小</p>
<p>-g 以GB为单位显示文件大小</p>
<p>-h 以易读方式显示文件大小</p>
<p>-s 仅显示总计</p>
<p>-c或–total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>以易读方式显示文件夹内及子文件夹大小</p>
<pre><code>du -h scf/
</code></pre>
</li>
<li>
<p>以易读方式显示文件夹内所有文件大小</p>
<pre><code>du -ah scf/
</code></pre>
</li>
<li>
<p>显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>
<pre><code>du -hc test/ scf/
</code></pre>
</li>
<li>
<p>输出当前目录下各个子目录所使用的空间</p>
<pre><code>du -hc --max-depth=1 scf/
</code></pre>
</li>
</ul>
<p>(4) ls命令</p>
<p>ls命令是list的缩写，通过ls命令不仅可以查看linux文件夹中包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限）以及查看目录信息等等。</p>
<p>常用参数搭配：</p>
<blockquote>
<p>ls -a 列出目录所有文件，包含以.开始的隐藏文件</p>
<p>ls -A 列出除.及…的其它文件</p>
<p>ls -r 反序排列</p>
<p>ls -t 以文件修改时间排序</p>
<p>ls -S 以文件大小排序</p>
<p>ls -h 以易读大小显示</p>
<p>ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>按易读方式按时间反序排序，并显示文件详细信息</p>
<pre><code>ls -lhrt
</code></pre>
</li>
<li>
<p>按大小反序显示文件详细信息</p>
<pre><code>ls -lrS
</code></pre>
</li>
<li>
<p>列出当前目录中所有以&quot;t&quot;开头的目录的详细内容</p>
<pre><code>ls -l t*
</code></pre>
</li>
<li>
<p>列出文件绝对路径（不包含隐藏文件）</p>
<pre><code>ls | sed &quot;s:^:'pwd'/:&quot;
</code></pre>
</li>
<li>
<p>列出文件绝对路径（包含隐藏文件）</p>
<pre><code>find $pwd -maxdepth 1 | xargs ls -ld
</code></pre>
</li>
</ul>
<p>(5) mkdir命令</p>
<p>mkdir命令用于创建文件夹，可用于选项：</p>
<ul>
<li>-m：对新建目录设置存取权限，也可以用chmod命令设置</li>
<li>-p：可以是一个路径名称，若路径中的某些目录尚不存在，加上此选项后，，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>当前工作目录下创建名为t的文件夹</p>
<pre><code>mkdir t
</code></pre>
</li>
<li>
<p>在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建</p>
<pre><code>mkdir -p /tmp/test/t1/t
</code></pre>
</li>
</ul>
<p>(6) pwd命令</p>
<p>pwd命令用于查看当前工作目录路径。</p>
<p>实例：</p>
<ul>
<li>
<p>查看当前路径</p>
<pre><code>pwd
</code></pre>
</li>
<li>
<p>查看软链接的实际路径</p>
<pre><code>pwd -d
</code></pre>
</li>
</ul>
<p>(7) rmdir命令</p>
<p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p>
<p>注意：不能删除非空目录</p>
<p>实例：</p>
<ul>
<li>
<p>当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除</p>
<pre><code>rmdir -p parent/child/child1
</code></pre>
</li>
</ul>
<h4 id="网络通讯命令">网络通讯命令</h4>
<p>(1) ifconfig命令</p>
<ul>
<li>ifconfig用于查看和配置Linux系统的网络接口</li>
<li>查看所有网络接口及其状态：<code>ifconfig -a</code></li>
<li>使用up和down命令启动或停止某个接口：<code>ifconfig eth0 up</code>和<code>ifconfig eth0 down</code></li>
</ul>
<p>(2) iptables命令</p>
<p>iptables，是一个配置Linux内核防火墙的命令行工具，功能非常强大，应当掌握如何开放端口。</p>
<ul>
<li>
<p>把来源IP为192.168.1.101访问本机80端口的包直接拒绝：<code>iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT</code></p>
</li>
<li>
<p>开启80端口，因为web对外都是这个端口</p>
<pre><code>iptables -A INPUT -p tcp --dport 80 -j ACCEP
</code></pre>
</li>
<li>
<p>另外，要注意使用<code>iptables save</code>命令，进行保存，否则，服务器重启后，配置的规则将丢失</p>
</li>
</ul>
<p>(3) netstat命令</p>
<p>Linux netstat命令用于显示网络状态。</p>
<p>利用netstat指令可得知整个Linux系统的网络情况</p>
<p>语法：</p>
<pre><code>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]
</code></pre>
<p>参数说明：</p>
<blockquote>
<p>-a或–all 显示所有连线中的Socket。<br>
-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。<br>
-c或–continuous 持续列出网络状态。<br>
-C或–cache 显示路由器配置的快取信息。<br>
-e或–extend 显示网络其他相关信息。<br>
-F或–fib 显示FIB。<br>
-g或–groups 显示多重广播功能群组组员名单。<br>
-h或–help 在线帮助。<br>
-i或–interfaces 显示网络界面信息表单。<br>
-l或–listening 显示监控中的服务器的Socket。<br>
-M或–masquerade 显示伪装的网络连线。<br>
-n或–numeric 直接使用IP地址，而不通过域名服务器。<br>
-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。<br>
-o或–timers 显示计时器。<br>
-p或–programs 显示正在使用Socket的程序识别码和程序名称。<br>
-r或–route 显示Routing Table。<br>
-s或–statistice 显示网络工作信息统计表。<br>
-t或–tcp 显示TCP传输协议的连线状况。<br>
-u或–udp 显示UDP传输协议的连线状况。<br>
-v或–verbose 显示指令执行过程。<br>
-V或–version 显示版本信息。<br>
-w或–raw 显示RAW传输协议的连线状况。<br>
-x或–unix 此参数的效果和指定&quot;-A unix&quot;参数相同。<br>
–ip或–inet 此参数的效果和指定&quot;-A inet&quot;参数相同。</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>如何查看系统都开启了哪些端口</p>
<pre><code>[root@centos6 ~ 13:20 #55]# netstat -lnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd
tcp        0      0 :::22                       :::*                        LISTEN      1035/sshd
udp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient
Active UNIX domain sockets (only servers)
Proto RefCnt Flags       Type       State         I-Node PID/Program name    Path
unix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart
unix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon
</code></pre>
</li>
<li>
<p>如何查看网络连接状况</p>
<pre><code>[root@centos6 ~ 13:22 #58]# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN
tcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED
tcp        0      0 :::22                       :::*                        LISTEN
udp        0      0 0.0.0.0:68                  0.0.0.0:*
</code></pre>
</li>
<li>
<p>如何统计系统当前进程连接数</p>
<ul>
<li>输入命令<code>netstat -an | grep ESTABLISHED | WC -L</code></li>
<li>输出结果<code>177</code>，一共有177连接数</li>
</ul>
</li>
</ul>
<p>(4) ping命令</p>
<p>Linux ping 命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应这条信息，因而得知该主机运作正常。</p>
<p>实例：</p>
<ul>
<li>
<p>指定接收包的次数</p>
<pre><code>ping -c 2 www.baidu.com
</code></pre>
</li>
</ul>
<p>(5) telnet命令</p>
<p>Linux telnet命令用于远端登入。</p>
<p>执行telnet指令开启终端机阶段作业，并登入远端主机。</p>
<p>语法：</p>
<pre><code>telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]
</code></pre>
<p>参数说明：</p>
<blockquote>
<p>-8 允许使用8位字符资料，包括输入与输出。<br>
-a 尝试自动登入远端系统。<br>
-b&lt;主机别名&gt; 使用别名指定远端主机名称。<br>
-c 不读取用户专属目录里的.telnetrc文件。<br>
-d 启动排错模式。<br>
-e&lt;脱离字符&gt; 设置脱离字符。<br>
-E 滤除脱离字符。<br>
-f 此参数的效果和指定&quot;-F&quot;参数相同。<br>
-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。<br>
-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。<br>
-K 不自动登入远端主机。<br>
-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。<br>
-L 允许输出8位字符资料。<br>
-n&lt;记录文件&gt; 指定文件记录相关信息。<br>
-r 使用类似rlogin指令的用户界面。<br>
-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。<br>
-x 假设主机有支持数据加密的功能，就使用它。<br>
-X&lt;认证形态&gt; 关闭指定的认证形态。</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>登录远程主机</p>
<pre><code># 登录IP为 192.168.0.5 的远程主机
telnet 192.168.0.5
</code></pre>
</li>
</ul>
<h4 id="系统管理命令">系统管理命令</h4>
<p>(1) date命令</p>
<p>显示或设定系统的日期与时间。</p>
<p>命令参数：</p>
<blockquote>
<p>-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。<br>
-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。<br>
-u 　显示GMT。<br>
%H 小时(00-23)<br>
%I 小时(00-12)<br>
%M 分钟(以00-59来表示)<br>
%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。<br>
%S 秒(以本地的惯用法来表示)<br>
%a 星期的缩写。<br>
%A 星期的完整名称。<br>
%d 日期(以01-31来表示)。<br>
%D 日期(含年月日)。<br>
%m 月份(以01-12来表示)。<br>
%y 年份(以00-99来表示)。<br>
%Y 年份(以四位数来表示)。</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示下一天</p>
<pre><code>date +%Y%m%d --date=&quot;+1 day&quot;  //显示下一天的日期
</code></pre>
</li>
<li>
<p>-d参数使用</p>
<pre><code>date -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三
date -d '2 weeks' 2周后的日期
date -d 'next monday' (下周一的日期)
date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d
date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d
date -d last-month +%Y%m(上个月是几月)
date -d next-month +%Y%m(下个月是几月)
</code></pre>
</li>
</ul>
<p>(2) free命令</p>
<p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核区缓存。</p>
<p>命令参数：</p>
<blockquote>
<p>-b 以Byte显示内存使用情况</p>
<p>-k 以kb为单位显示内存使用情况</p>
<p>-m 以mb为单位显示内存使用情况</p>
<p>-g 以gb为单位显示内存使用情况</p>
<p>-s&lt;间隔秒数&gt; 持续显示内存 -t 显示内存使用总合</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示内存使用情况</p>
<pre><code>free
free -k
free -m
</code></pre>
</li>
<li>
<p>以总和的形式显示内存的使用信息</p>
<pre><code>free -t
</code></pre>
</li>
<li>
<p>周期性查询内存使用情况</p>
<pre><code>free -s 10
</code></pre>
</li>
</ul>
<p>(3) kill命令</p>
<p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用&quot;-KILL&quot; 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p>
<p>常用参数：</p>
<blockquote>
<p>-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</p>
<p>-a  当处理当前进程时，不限制命令名和进程号的对应关系</p>
<p>-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</p>
<p>-s  指定发送信号 -u  指定用户</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>先使用ps查找进程pro1，然后用kill杀掉</p>
<pre><code>kill -9 $(ps -ef | grep pro1)
</code></pre>
</li>
</ul>
<p>(4) ps命令</p>
<p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top linux上进程有5种状态：</p>
<ul>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中，受阻，在等待某个条件的形成或接收到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行，进程必须等待直到有中断发生)</li>
<li>僵死(进程已终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放)</li>
<li>停止(进程收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU信号后停止运行)</li>
</ul>
<p>ps工具标识进程的5种状态码：</p>
<blockquote>
<p>D 不可中断 uninterruptible sleep (usually IO)<br>
R 运行 runnable (on run queue)<br>
S 中断 sleeping<br>
T 停止 traced or stopped<br>
Z 僵死 a defunct (”zombie”) process</p>
</blockquote>
<p>命令参数：</p>
<blockquote>
<p>-A 显示所有进程</p>
<p>a 显示所有进程</p>
<p>-a 显示同一终端下所有进程</p>
<p>c 显示进程真实名称</p>
<p>e 显示环境变量</p>
<p>f 显示进程间的关系</p>
<p>r 显示当前终端运行的进程</p>
<p>-aux 显示所有包含其它使用的进程</p>
</blockquote>
<p>实例：</p>
<ul>
<li>
<p>显示当前所有进程环境变量及进程间关系</p>
<pre><code>ps -ef
</code></pre>
</li>
<li>
<p>显示当前所有进程</p>
<pre><code>ps -A
</code></pre>
</li>
<li>
<p>与grep联用查找某进程</p>
<pre><code>ps -aux | grep apache
</code></pre>
</li>
<li>
<p>找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<pre><code>ps aux | grep '(cron|syslog)'
</code></pre>
</li>
</ul>
<p>(5) rpm命令</p>
<p>Linux rpm命令用于管理套件。</p>
<p>rpm(redhat package manager)原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎，逐渐受到其他发行版的采用。RPM套件管理方式的出现，让Linux易于安装、升级，间接提升了Linux的适用度。</p>
<p>使用语法：</p>
<pre><code># 查看系统自带jdk
rpm -qa | grep jdk
# 删除系统自带jdk
rpm -e --nodeps 查看jdk显示的数据
# 安装jdk
rpm -ivh jdk-7u80-linux-x64.rpm
</code></pre>
<p>(6) top命令</p>
<p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p>
<p>常用参数：</p>
<blockquote>
<p>-c 显示完整的进程命令</p>
<p>-s 保密模式</p>
<p>-p &lt;进程号&gt; 指定进程显示</p>
<p>-n &lt;次数&gt;循环显示次数</p>
</blockquote>
<p>实例：</p>
<pre><code>top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35
Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie
Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st
Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers
Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  
28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java
</code></pre>
<p><strong>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</strong></p>
<p>14:06:23 — 当前系统时间</p>
<p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p>
<p>2 users — 当前有2个用户登录系统</p>
<p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
<p><strong>第二行，Tasks — 任务（进程），具体信息说明如下：</strong></p>
<p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p><strong>第三行，cpu状态信息，具体属性说明如下</strong>：</p>
<p>5.9%us — 用户空间占用CPU的百分比。<br>
3.4% sy — 内核空间占用CPU的百分比。<br>
0.0% ni — 改变过优先级的进程占用CPU的百分比<br>
90.4% id — 空闲CPU百分比<br>
0.0% wa — IO等待占用CPU的百分比<br>
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比<br>
0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<p><strong>第四行，内存状态，具体信息如下：</strong></p>
<p>32949016k total — 物理内存总量（32GB）</p>
<p>14411180k used — 使用中的内存总量（14GB）</p>
<p>18537836k free — 空闲内存总量（18GB）</p>
<p>169884k buffers — 缓存的内存量 （169M）</p>
<p><strong>第五行，swap交换分区信息，具体信息说明如下</strong>：</p>
<p>32764556k total — 交换区总量（32GB）</p>
<p>0k used — 使用的交换区总量（0K）</p>
<p>32764556k free — 空闲交换区总量（32GB）</p>
<p>3612636k cached — 缓冲的交换区总量（3.6GB）</p>
<p><strong>第六行，空行。</strong></p>
<p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下</strong>：</p>
<p>PID — 进程id<br>
USER — 进程所有者<br>
PR — 进程优先级<br>
NI — nice值。负值表示高优先级，正值表示低优先级<br>
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>
SHR — 共享内存大小，单位kb<br>
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>
%CPU — 上次更新到现在的CPU时间占用百分比<br>
%MEM — 进程使用的物理内存百分比<br>
TIME+ — 进程使用的CPU时间总计，单位1/100秒<br>
COMMAND — 进程名称（命令名/命令行）</p>
<p>top交互命令：</p>
<blockquote>
<p>h 显示top交互命令帮助信息</p>
<p>c 切换显示命令名称和完整命令行</p>
<p>m 以内存使用率排序</p>
<p>P 根据CPU使用百分比大小进行排序</p>
<p>T 根据时间/累计时间进行排序</p>
<p>W 将当前设置写入~/.toprc文件中</p>
<p>o或者O 改变显示项目的顺序</p>
</blockquote>
<p>(7) yum命令</p>
<p>yum（Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p>
<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令：</p>
<ul>
<li>列出所有可更新的软件清单命令：yum check-update</li>
<li>更新所有软件命令：yum update</li>
<li>仅安装指定的软件命令：yum install &lt;package_name&gt;</li>
<li>仅更新指定的软件命令：yum update &lt;package_name&gt;</li>
<li>列出所有可安裝的软件清单命令：yum list</li>
<li>删除软件包命令：yum remove &lt;package_name&gt;</li>
<li>查找软件包 命令：yum search</li>
<li>清除缓存命令:
<ul>
<li>yum clean packages: 清除缓存目录下的软件包</li>
<li>yum clean headers: 清除缓存目录下的 headers</li>
<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>
<li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>
</ul>
</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>安装pam-devel</p>
<pre><code>[root@www ~]# yum install pam-devel
</code></pre>
</li>
</ul>
<h4 id="备份压缩命令">备份压缩命令</h4>
<p>(1) bzip2命令</p>
<ul>
<li>创建<code>*.bz2</code>压缩文件：<code>bzip2 test.txt</code></li>
<li>解压<code>*.bz2</code>文件：<code>bzip2 -d test.txt.bz2</code></li>
</ul>
<p>(2) gzip命令</p>
<ul>
<li>创建一个<code>*.gz</code>的压缩文件：<code>gzip test.txt</code></li>
<li>解压<code>*.gz</code>文件：<code>gzip -d test.txt.gz</code></li>
<li>显示压缩的比例：<code>gzip -l *.gz</code></li>
</ul>
<p>(3) tar命令</p>
<p>用来压缩和解压文件，tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p>
<p>打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>常用参数：</p>
<blockquote>
<p>-c 建立新的压缩文件</p>
<p>-f 指定压缩文件</p>
<p>-r 添加文件到已经压缩文件包中</p>
<p>-u 添加改了和现有的文件到压缩包中</p>
<p>-x 从压缩包中抽取文件</p>
<p>-t 显示压缩文件中的内容</p>
<p>-z 支持gzip压缩</p>
<p>-j 支持bzip2压缩</p>
<p>-Z 支持compress解压文件</p>
<p>-v 显示操作过程</p>
</blockquote>
<p>有关gzip和bzip2压缩：</p>
<pre><code>gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz
          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz

bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2
       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2
</code></pre>
<p>实例：</p>
<ul>
<li>
<p>将文件全部打包成 tar 包</p>
<pre><code>tar -cvf log.tar 1.log,2.log
tar -cvf log.*
</code></pre>
</li>
<li>
<p>将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p>
<pre><code>tar -zcvf /tem/etc.tar.gz /etc
</code></pre>
</li>
<li>
<p>查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）</p>
<pre><code>tar -ztvf /tmp/etc/tar/gz
</code></pre>
</li>
<li>
<p>要压缩打包 /home, /etc ，但不要 /home/dmtsai</p>
<pre><code>tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc
</code></pre>
</li>
</ul>
<p>(4) unzip命令</p>
<ul>
<li>解压<code>*.zip</code>文件：<code>unzip test.zip</code></li>
<li>查看<code>*.zip</code>文件的内容：<code>unzip -l jasper.zip</code></li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2020/07/22/Linux基础/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2020/07/22/Linux基础/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":1.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":-25,"vOffset":-20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":1.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":-25,"vOffset":-20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>



 	
</html>
