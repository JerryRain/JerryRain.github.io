<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">

	
			    <title>
    JerryRain
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="JR">

    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/kobe.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/love.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>
    
		
<!-- Layouts -->


<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<link rel="stylesheet" href="/css/mouse.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    
        <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Go on</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/BLOG/">BLOG</a></li><li><a class="category-link" href="/categories/CODING/">CODING</a></li><li><a class="category-link" href="/categories/Markdown/">Markdown</a></li><li><a class="category-link" href="/categories/blog/">blog</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">归档</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2019/05/">May 2019</a></li><li><a class="archive-link" href="/archives/2019/04/">April 2019</a>
	                    </li></ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/JerryRain?tab=repositories" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://v.qq.com/x/page/p0753p3sozo.html" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://www.geeksforgeeks.org/wp-content/uploads/titleShadow-768x256.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++学习笔记</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p></p><h2 style="text-align:center">C++基础笔记</h2><p></p>
<h3 id="一-c语言与c-的区别">一.C语言与C++的区别</h3>
<p>C语言：面向过程（函数与函数交互）​ 🙈</p>
<p>C++：增加面向对象机制（对象与对象交互）-- 一种管理源代码的方式​ 🙉</p>
<p>对C语言的扩充：</p>
<p>1.变量的定义可以出现在程序的任意行</p>
<p>2.提供了标准输入输出流对象</p>
<p>3.用<strong>const</strong>定义常变量</p>
<p>4.函数重载、函数模板、带默认值的函数</p>
<p>5.引用类型</p>
<p>6.单目作用域运算符</p>
<p>7.string类型字符串</p>
<p>8.使用<strong>new</strong>和<strong>delete</strong>代替malloc和free函数等</p>
<h3 id="二-第一个helloworld程序">二.第一个Helloworld程序</h3>
<p>😆👀 👀 👀 👀 👀 👀 👀 👀 👀 👀 👀 👀 👀 👀 😆</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    cout << "HelloWorld!" << endl;
    return 0;
}
</iostream></code></pre>
<ul>
<li>
<p><strong>头文件</strong><br>
以#开头的语句成为<strong>预处理器指令</strong>；</p>
<p>#include语句不是必须的，但是如果一旦程序中有该语句，就必须将它放在程序的开始处。</p>
</li>
<li>
<p>将iostream文件的内容添加到程序中；<br>
iostream : input &amp; ouput stream(输入输出流)<br>
iostream中包含了有关输入输出语句的函数。</p>
<pre class="mermaid">  graph LR;
A[头文件类型] -->B(C旧式风格--以.h结尾);
A -->C(C++旧式风格--以.h结尾);
A -->D(C++新式风格--没有扩展名);
A -->E(转换后的C--加上前缀c,没有扩展名);</pre>
</li>
</ul>
<ul>
<li>
<p>使用命名空间std<br>
<code>std :: cout &lt;&lt; &quot;HelloWorld!&quot; &lt;&lt; std::endl;</code><br>
其他用法：</p>
<ul>
<li>
<p>using std::cout;</p>
</li>
<li>
<p>using std::cin;</p>
</li>
<li>
<p>using std::endl;</p>
</li>
</ul>
</li>
<li>
<p>&lt;&lt;符号表示把字符串&quot;HelloWorld!&quot;发送到cout打印，把一个字符串插入到了输出流中；<br>
endl是控制符，表示重起一行(\n),表示回车；<br>
<strong>原理说明</strong>：<br>
1.从概念上看，输出是一个流，可以理解成从程序流出的一系列字符<br>
2.cout对象表示这种流，在iostream文件中定义<br>
3.cout右边&lt;&lt;符号是<strong>插入运算符</strong>，可以将右侧信息插入到流中<br>
<strong>endl 和 \n的区别</strong>：<br>
1.\n仅仅表示换行<br>
2.endl表示换行和清空缓存区</p>
</li>
</ul>
<h2 id="三-c-编程规范">三.C++编程规范</h2>
<p>1.每条语句占一行</p>
<p>2.每个函数都有一个开始与结束花括号，花括号各占一行</p>
<p>3.函数中的语句对相对于花括号进行缩进</p>
<p>4.与函数名称相关的小括号周围没有空白</p>
<p>5.注释：</p>
<ul>
<li>单行注释：以”//“开头</li>
<li>多行注释：以<code>/*</code>开头，以<code>*/</code>结尾i</li>
</ul>
<p>6.编译和执行</p>
<ul>
<li>编译（预处理-&gt;编译-&gt;目标文件-&gt;汇编）</li>
<li>连接</li>
<li>执行</li>
</ul>
<h2 id="四-基础知识">四.基础知识</h2>
<h3 id="第一章：变量-数据类型及运算符">第一章：变量、数据类型及运算符</h3>
<p>计算机使用<strong>内存</strong>来记忆或储存计算时所使用的数据。</p>
<p>计算机执行程序时，组成程序的指令和程序所操作的数据都必须存放在某个地方——<strong><em>计算机的内存</em></strong>，也称为<strong>主存</strong>（main memory）或<strong>随机访问储存器</strong>（RAM）。</p>
<p>储存单位：bit（位）/ binary digit（二进制数字）</p>
<p><strong>1.变量</strong></p>
<p>定义：变量是计算机中一块特定的内存空间，由一个或多个连续的字节组成。</p>
<p>1 byte 字节 = 8 bit 比特</p>
<p>10M （bit per second）</p>
<p>变量：一个数据储存空间的表示</p>
<p>不同数据存入具有不同内存地址的空间，相互独立</p>
<p>变量的命名：通过变量名可以简单快速地找到在内存中储存的数据</p>
<p><strong>C++语言变量命名规则：</strong></p>
<p>1、变量名（标识符）只能由<strong><em>字母、数字和下划线</em></strong> 3种字符组成</p>
<p>2、名称第一个字符必须为<strong><em>字母或下划线</em></strong>，不能是数字</p>
<p>3、变量名不能包含除_以外的任何特殊字符，如：%、#、逗号、空格等</p>
<p>4、不可以使用保留字/关键字</p>
<p>5、不要使用拼音</p>
<p>6、尽量不要使用单个英文单词</p>
<p>7、提倡使用由正式含义的英文单词</p>
<p><strong>2.数据类型</strong></p>
<pre class="mermaid">graph LR;
A[数据类型] -->B(数值);
A --> C(非数值);
B --> D(整型);
B --> E(浮点型);
D --> F(int);
D --> G(short);
D --> H(long);
D --> I(long long);
D --> N(char);
D --> O(bool);
E --> J(float);
E --> K(double);
E --> L(long double);
C --> M(string);</pre>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">类型说明符</th>
<th style="text-align:center">位数</th>
<th style="text-align:right">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>整型</td>
<td style="text-align:center">int</td>
<td style="text-align:center">32</td>
<td style="text-align:right">-2147483648~+2147483647</td>
</tr>
<tr>
<td>短整型</td>
<td style="text-align:center">short int</td>
<td style="text-align:center">16</td>
<td style="text-align:right">-32767~+32768</td>
</tr>
<tr>
<td>长整型</td>
<td style="text-align:center">long int</td>
<td style="text-align:center">32</td>
<td style="text-align:right">-2147483648~+2147483647</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td style="text-align:center">float</td>
<td style="text-align:center">32</td>
<td style="text-align:right">-3.4E-38~+3.4E+38</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td style="text-align:center">double</td>
<td style="text-align:center">64</td>
<td style="text-align:right">1.7E-308~+1.7E308</td>
</tr>
<tr>
<td>字符型</td>
<td style="text-align:center">char</td>
<td style="text-align:center">8</td>
<td style="text-align:right">-128~+127</td>
</tr>
</tbody>
</table>
<p>整型可以用来储存整数；</p>
<p>短整型用于储存位数较少的整数；</p>
<p>长整型用于储存位数较多的整数，C语言中，int和long的位数是相同的，取值范围也相同，long long是64位，取值范围是-9223372036854775808~+9223372036854775807；</p>
<p>单精度浮点型用于储存位数较少的小树（7位有效数字）；</p>
<p>双精度浮点型用于储存位数较多的小数（16位有效数字）；</p>
<p>字符型可用于储存单个字符。</p>
<p>C++其他数据类型：</p>
<p>size_t类型、枚举类型、自定义类型、指针类型、空类型等</p>
<p>数据类型用来规定内存所占用的空间。</p>
<p><strong>3.声明变量</strong></p>
<p>声明变量：</p>
<p>DataType variableName; (数据类型 变量名；)</p>
<p>定义时初始化变量：</p>
<p>DataType variableName = value; (数据类型 变量名 = 值；)</p>
<p>定义后初始化变量：</p>
<p>DataType variableName; (数据类型 变量名；)</p>
<p>variableName = value; (变量名 = 值；)</p>
<p><strong><em>example:</em></strong></p>
<p>1、声明整型变量（声明并初始化）：</p>
<p>int XXX / short int XXX / long XXX …</p>
<p>注意：</p>
<ul>
<li>变量名注意不要重复</li>
<li>一条语句可以声明多个类型相同的变量（用逗号空格隔开）</li>
</ul>
<p>2、声明浮点型变量（声明并初始化）：</p>
<p>float XXX / float XXX = …</p>
<pre class="mermaid">graph LR;
A[float] --> B(位数:32位);
A --> C(空间:4个字节);
A --> D(取值范围:-3.4E+38 至 +3.4E+38);
A --> E(6至7位有效数字);</pre>
<p>注意：</p>
<ul>
<li>float类型变量赋值时建议在数值的末尾加上一个f</li>
<li>cmath头文件定义了C++中的库函数，其中的c表示函数是来自c标准库的函数，math为数学常用库函数</li>
</ul>
<p>3、声明双精度浮点型变量（声明并初始化）：</p>
<p>double XXX / double XXX = …</p>
<pre class="mermaid">graph LR;
A[double] --> B(位数:64位);
A --> C(空间:8个字节);
A --> D(取值范围:-1.7E308 至 1.7E308);
A --> E(15位有效数字);</pre>
<p>控制cout的显示精度：</p>
<ul>
<li>强制以小数的方式显示：<code>cout &lt;&lt; fixed ;</code></li>
<li>控制显示的精度 : <code>cout &lt;&lt; setprecision(显示小数点位数) ;</code>（需导入iomanip头文件）</li>
<li>setw()函数可以用来设置宽度大小，只与后面的元素相关</li>
</ul>
<p><strong>4.打印</strong></p>
<p>改变打印窗口标题名称：<code>SerConsoleTitle(&quot;XXX&quot;);</code></p>
<p>cin函数：<code>cin &gt;&gt; XXX</code>(只能读取一个字符型) / <code>cin.get()</code></p>
<p>cout函数：<code>cout &lt;&lt; XXX</code> / <code>cout &lt;&lt; left</code>(左起填充) / <code>cout &lt;&lt; setfill('_')</code>（以下划线形式填充）</p>
<p><strong>5.转义字符</strong></p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th style="text-align:center">名称</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td style="text-align:center">蜂鸣警报</td>
<td style="text-align:right">在一些系统中警报不起作用</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">退格</td>
<td style="text-align:right">将光标退回一格</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:center">换页</td>
<td style="text-align:right">将光标移到下一页的开始处</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:center">换行</td>
<td style="text-align:right">将光标移到下一行的开始处</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:center">回车</td>
<td style="text-align:right">j将光标移到当前行的开始处</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:center">水平制表</td>
<td style="text-align:right">将光标移到下一个水平制表位置</td>
</tr>
<tr>
<td>\v</td>
<td style="text-align:center">垂直制表</td>
<td style="text-align:right">将光标移到下一个垂直制表位置</td>
</tr>
<tr>
<td>\’</td>
<td style="text-align:center">单引号</td>
<td style="text-align:right">用于打印单引号字符</td>
</tr>
<tr>
<td>‘’</td>
<td style="text-align:center">双引号</td>
<td style="text-align:right">用于打印双引号字符</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:center">问号</td>
<td style="text-align:right">用于打印问号字符</td>
</tr>
<tr>
<td>\\</td>
<td style="text-align:center">反斜线</td>
<td style="text-align:right">用于打印反斜线字符</td>
</tr>
</tbody>
</table>
<p><strong>6.算数运算符</strong></p>
<p>一元运算符：++（后置） 、 --（前置）</p>
<p>二元运算符：+ 、- 、* 、/（取模） 、%（取余）</p>
<p>表达式：符号与操作数的组合</p>
<p>取模的应用场景：用到循环的是或，比如取某个数字的个位（取模的符号与除数的符号一致）</p>
<p><strong>7.类型转换</strong></p>
<p>原则：把表示范围小的类型的值转换到表示范围大的类型的值</p>
<p>short --&gt; int --&gt; long --&gt; float --&gt; double</p>
<p>强制类型转换语法：<strong><em>（类型名）变量或数值</em></strong></p>
<h3 id="第二章-表达式与条件结构">第二章 表达式与条件结构</h3>
<p><strong>1.运算符与表达式</strong></p>
<p>**Ⅰ.赋值运算符 **：</p>
<table>
<thead>
<tr>
<th style="text-align:center">赋值运算符</th>
<th style="text-align:center">表示符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单等号</td>
<td style="text-align:center">=</td>
</tr>
</tbody>
</table>
<p>计算顺序：</p>
<p>复合运算符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">复合运算符</th>
<th style="text-align:center">表示符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">加等</td>
<td style="text-align:center">+=</td>
</tr>
<tr>
<td style="text-align:center">减等</td>
<td style="text-align:center">-=</td>
</tr>
<tr>
<td style="text-align:center">乘等</td>
<td style="text-align:center">*=</td>
</tr>
<tr>
<td style="text-align:center">除等</td>
<td style="text-align:center">/=</td>
</tr>
<tr>
<td style="text-align:center">模等</td>
<td style="text-align:center">%=</td>
</tr>
</tbody>
</table>
<p>计算顺序：从左往右</p>
<pre class="mermaid">graph LR;
A[运算符] --> B(赋值运算符);
A --> C(算数运算符);
A --> D(关系运算符);
A --> E(逻辑运算符);</pre>
<p>表达式：符号与操作数的组合</p>
<p><strong>Ⅱ.关系运算符</strong>：</p>
<p>关系运算符可以比较大小、高低、长短（返回布尔类型0或1 true or false）</p>
<ul>
<li><code>&gt; 、&lt;</code></li>
<li><code>&gt;= 、 &lt;=</code></li>
<li>== 、 !=</li>
</ul>
<p><strong>Ⅲ·逻辑运算符</strong>：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp; 且</td>
<td style="text-align:center">条件1 &amp;&amp; 条件2</td>
<td style="text-align:right">两个结果同时为真，结果为真</td>
</tr>
<tr>
<td>|| 或</td>
<td style="text-align:center">条件1 || 条件2</td>
<td style="text-align:right">两个条件有一个为真，结果为真</td>
</tr>
<tr>
<td>！ 非</td>
<td style="text-align:center">！条件</td>
<td style="text-align:right">条件为真，结果为假<br>条件为假，结果为真</td>
</tr>
</tbody>
</table>
<p><strong>Ⅳ·位运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">两个操作数同时为1，结果为1</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">两个操作数只要有一个为1，结果就为1</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">按位非</td>
<td style="text-align:center">操作数为1，结果为0<br>操作数为0，结果为1</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或（同假异真）</td>
<td style="text-align:center">两个操作数相同，结果为0<br>两个操作数不同，结果为1</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td style="text-align:center">右侧空位补0</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center">y移动小数点，左侧空位补符号位</td>
</tr>
</tbody>
</table>
<p><strong><em>注意：</em></strong></p>
<p>按位非运算步骤：</p>
<p>1、二进制取反（一共有八位，自动补全）</p>
<p>2、补全的八位二进制数，第一位是符号位，0表示正数，1表示负数</p>
<p>3、将二进制转换成十进制：将二进制取反，然后加1，结果为负</p>
<p>例如2（十进制）按位非步骤：</p>
<p>1、转换成二进制：00000010（正数）</p>
<p>2、取反：11111101（负数）</p>
<p>3、再取反：00000010</p>
<p>4、加1：00000011（负数）</p>
<p>5、转换成十进制：-（2<sup>1+2</sup>0)=-3</p>
<p>左移右移运算例子：</p>
<p>2 &lt;&lt;3（表示将十进制的2左移3位之后表示的十进制数变成什么）</p>
<p>1、2转化成二进制是10</p>
<p>2、左移3位，右侧补3个0，变成二进制的10000</p>
<p>3、转化成十进制为：2^4=16</p>
<p><strong>Ⅴ· sizeof运算符</strong>：</p>
<p>使用sizeof运算符可以获得数据类型占用内存空间的大小</p>
<p>基本用法：<code>sizeof(type_name)</code></p>
<p>结果以<strong>字节</strong>为单位</p>
<p><strong>Ⅵ·三元运算符</strong>：</p>
<p>(判断条件 ？ A:B)</p>
<p>若判断条件为真，则取A；</p>
<p>若判断条件为假，则取B。</p>
<p><strong>2.运算符优先级</strong></p>
<p>①单目运算符包括！、~、++、–、sizeof，优先级别高</p>
<p>②优先级别最低的是<strong><em>赋值运算符</em></strong></p>
<p>③可以通过()控制表达式的运算顺序，()优先级最高</p>
<p>④从右往左结合性的只有赋值运算符、三目运算符和单目运算符</p>
<p>⑤算数运算符&gt;关系运算符&gt;逻辑运算符</p>
<p><strong>3.条件结构</strong></p>
<p><strong><em>if结构</em></strong></p>
<p>先判断后执行</p>
<pre class=" language-language-c++"><code class="language-language-c++">if(条件为真)
{
	//代码块1
}
else
{
    //代码块2
}
</code></pre>
<p><strong><em>多重if结构</em></strong></p>
<p>常用来进行区间判断</p>
<pre class=" language-language-c++"><code class="language-language-c++">if(条件1)
{
    //代码1
}
else if(条件2)
{
    //代码2
}
else
{
    //代码3
}
</code></pre>
<p><strong><em>switch结构</em></strong></p>
<p>注意：</p>
<p>1、switch后的表达式只能是<strong>整型</strong>或<strong>字符型</strong></p>
<p>2、case后常量表达式的值不能相同</p>
<p>3、case后允许多条语句，不需要大括号</p>
<p>4、如果不添加break语句，需要特别注意执行顺序</p>
<p>5、case和default子句的先后顺序可以自行变动</p>
<p>6、default子句可以省略</p>
<p>7、break跳出循环</p>
<pre class=" language-language-c++"><code class="language-language-c++">switch(表达式)
{
    case 常量1:
    	语句1;
    	break;
    case 常量2:
    	语句2;
    	break;
    ......
    default:
    	语句;
}
</code></pre>
<p><strong><em>switch和多重if对比</em></strong>：</p>
<p><strong>相同点</strong>：</p>
<ul>
<li>都是用来处理分支条件的结构</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>switch：等值条件判断——条件是有限个的时候</li>
<li>多重if：判断某个连续区间时的情况</li>
</ul>
<h3 id="第三章-循环">第三章 循环</h3>
<p>循环中，可以通过控制循环变量，来控制循环次数。</p>
<p><strong><em>while循环</em></strong></p>
<p>基本语法：</p>
<pre class=" language-language-c++"><code class="language-language-c++">while(循环条件)
{
    循环操作语句
}
</code></pre>
<p>循环三要素：</p>
<ul>
<li>循环变量的初值</li>
<li>循环变量的判断</li>
<li>循环变量的更新</li>
</ul>
<p>特点：<strong>先判断，再执行</strong></p>
<p><strong><em>do-while循环</em></strong></p>
<p>基本语法：</p>
<pre class=" language-language-c++"><code class="language-language-c++">do
{
    循环操作
}while(循环条件)
</code></pre>
<p>特点：<strong>先执行，再判断</strong></p>
<ul>
<li>先执行一遍循环操作</li>
<li>符号条件，循环继续执行</li>
<li>否则循环退出</li>
</ul>
<p>while和do-while循环的区别：</p>
<ul>
<li>执行顺序不同</li>
<li>初识情况不满足循环条件时：
<ul>
<li>while循环一次都不会执行</li>
<li>do-while循环不管任何情况都至少执行一次</li>
</ul>
</li>
</ul>
<p><strong><em>for循环</em></strong></p>
<p>语法：</p>
<pre class=" language-language-c++"><code class="language-language-c++">for(表达式1;表达式2;表达式3;)
{
    语句;
}
</code></pre>
<p>表达式1：通常是为循环变量赋初值，可省略</p>
<p>表达式2：循环条件，是否继续执行循环，可省略</p>
<p>表达式3：更新循环变量的值，可省略</p>
<p>for循环常见问题：</p>
<p>1、忘记定义循环变量或初始化</p>
<p>2、循环条件缺少时会造成死循环</p>
<p>3、循环变量不更新也会造成死循环</p>
<p>4、不可省略分号</p>
<p><strong><em>break语句</em></strong></p>
<p>break语句的作用：跳出循环，执行循环之后的语句</p>
<pre class=" language-language-c++"><code class="language-language-c++">while(循环条件)
{
    ......
    ......
    break;(跳出整个循环，不执行下面的语句)
    ......
    ......
}
</code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">do
{
    ......
    ......
    break;(跳出整个循环，不执行下面的语句)
    ......
    ......
}while(循环条件)
</code></pre>
<p><strong><em>continue语句</em></strong></p>
<p>continue语句作用：跳出本次循环，继续下次循环</p>
<pre class=" language-language-c++"><code class="language-language-c++">while(循环条件)
{
    ......
    ......
    continue;(跳出本次循环之后继续判断是否再次进入循环)
    ......
    ......
}
</code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">do
{
    ......
    ......
    continue;(跳出本次循环之后继续判断是否再次进入循环)
    ......
    ......
}
</code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">for(;循环条件;更新循环变量)
{
    ......
    ......
    continue;(跳出本次循环之后继续判断是否再次进入循环)
    ......
    ......
}
</code></pre>
<p><strong><em>break和continue对比</em></strong>：</p>
<p>使用场合</p>
<ul>
<li>break可用于switch结构和循环结构中</li>
<li>continue只能用于循环结构中</li>
</ul>
<p>作用（循环结构中）</p>
<ul>
<li>break语句终止某个循环，程序跳转到循环块外的下一条语句</li>
<li>continue跳出本次循环，进入下一次循环</li>
</ul>
<p><strong>循环结构总结</strong>：</p>
<p>相同点：</p>
<ul>
<li>多次重复执行一个或多个任务时考虑使用循环来解决问题</li>
</ul>
<p>区别：</p>
<ul>
<li>除了语法不同，判断和执行的顺序也不同</li>
<li>使用情况不同
<ul>
<li>循环次数确定的情况下，通常选用for循环</li>
<li>循环次数不确定的情况时，通常选用while和do-while循环</li>
</ul>
</li>
</ul>
<p><strong>嵌套循环——打印图案</strong></p>
<p>线段——&gt;直线——&gt;一维——&gt;单循环</p>
<p>平面——&gt;二维——&gt;双循环（嵌套循环）</p>
<p>比如，打印一个星星矩形：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    for(int i = 0; i < 5; i++)
    {
        for(int j = 0; j < 5; j++)
        {
            cout << "*" << endl;
        }
    }
}
</iostream></code></pre>
<p>打印三角形：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    for(int i = 0; i < 5; i++)
    {
        for(int j = 0; j <= i; j++) { cout << "*" endl; } < code></=></iostream></code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    for(int i = 0; i < 5; i++)
    {
        for(int j = 0; j <= 2 * i; j++) { cout << "*" endl; } < code></=></iostream></code></pre>
<p>打印菱形：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    for(int i = 0; i < 4; i++)
    {
        for(int j = 0; j <= 2 - i; j++) { cout << " "; } for(int j="0;" <="2" * "*"; endl; i="0;" 3; i++) code></=></iostream></code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    for(int i = 0; i < 4; i++)
    {
        for(int j = 0; j <= 0 2 4 - i; j++) { cout << " "; } for(int j="0;" <="2" * if(j="=" || 2*i) "*"; else endl; i="0;" 3; i++) i) code></=></iostream></code></pre>
<p>技巧：</p>
<p>外层循环控制行（行数，换行）</p>
<p>内层循环控制列（列数，列的图形）</p>
<h3 id="第四章-数组及常用算法">第四章.数组及常用算法</h3>
<p><strong>1.数组的定义</strong></p>
<ul>
<li>
<p>数组是一个变量，由数据类型相同的一组元素组成。</p>
</li>
<li>
<p>变量：内存中的一块空间</p>
</li>
<li>
<p>数组：内存中的一串连续的空间</p>
</li>
</ul>
<p><strong>2.数组的结构和基本要素</strong></p>
<ul>
<li>
<p>标识符：数组的名称，用于去纷纷不同的数组</p>
</li>
<li>
<p>数组元素：向数组中存放的数据</p>
</li>
<li>
<p>元素下标：对数组元素进行编号（元素下标都是从0开始）</p>
</li>
<li>
<p>元素类型：数组元素的数据类型</p>
</li>
</ul>
<p><strong>3.数组的基本信息</strong></p>
<ul>
<li>数组只有一个名称，即标识符（用来表示数组的变量名）</li>
<li>元素下标标明了元素在数组中的位置，从0开始</li>
<li>数组中的每个元素都可以通过下标来访问</li>
<li>数组长度固定不变，避免数组越界</li>
<li>数组中的所有元素必须属于相同的数据类型</li>
<li>数组的大小一旦确定了，就不能再更改了</li>
</ul>
<p><strong>4.数组的使用</strong></p>
<p>语法：<code>datatype arrayName[size]</code></p>
<p><strong>错误写法</strong>：<s>int array[] = {};</s></p>
<p>初始化数组：</p>
<ul>
<li>元素个数与声明的一致</li>
<li>若元素未赋值，默认值为0，但至少要给一个元素赋值</li>
</ul>
<p>C++中的列表初始化新增了一些功能：</p>
<ul>
<li>省略=号，比如：int days[] {1,15};</li>
<li>大括号可为空，所有元素置零：float m[100] {};</li>
</ul>
<p>动态地从键盘录入信息并赋值：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    const int N = 5;
    int nums[N];
    for(int i = 0; i < N; i++)
    {
        cout << "请输入第" << (i+1) << "个数组元素:";
        cin >> nums[i];
    }
    for(int i = 0; i < N; i++)
    {
        cout << nums[i] << endl;
    }
}
</iostream></code></pre>
<p><strong><em>数组排序算法</em></strong></p>
<p><strong>Ⅰ.冒泡排序</strong></p>
<p>①第一轮比较的次数：数组的总长度-1</p>
<p>②下一轮比上一轮比较的次数少一次</p>
<p>③外层循环控制比较的轮数，内层循环控制每轮的比较和交换</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int temp;
int nums[] = {15,25,90,23,9};
for(int i = 0; i < 5 - 1; i++)
{
    for(int j = 0; j < 4 - i; j++)
    {
        if(nums[j] < nums[j+1])
        {
            temp = num[j];
            num[j] = num[j+1];
            num[j+1] = temp;
        }
    }
}
</iostream></code></pre>
<p><strong>Ⅱ.选择排序</strong></p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    int nums[] = {8,4,2,1,23,344,12};
    int numsLen = sizeof(nums) / sizeof(int);
    int temp;
    int min = nums[0]; //假设最小值是数组的第一个元素
    int minIndex = 0;  //最小值的初识下标设置为0
    for(int i = 0; i < numsLen ; i++)
    {
        min = nums[i];
        minIndex = i;
        for(int j = i + 1; j < numsLen ; j++)
        {
            if(nums[j] < min)
            {
                min = nums[j];
                minIndex = j;
            }
        }
        if(minIndex > i)
        {
            temp = nums[minIndex];
            nums[minIndex] = nums[i];
            nums[i] = temp;
        }
    }
    cout << "排序后：" << endl;
    for(int i = 0; i < numsLen; i++)
    {
        cout << nums[i] << endl;
    }
}
</iostream></code></pre>
<p><strong>Ⅲ.逆序</strong></p>
<pre class=" language-language-c++"><code class="language-language-c++">for(int i = 0; i < numsLen/2; i++)
{
    temp = nums[i];
    nums[i] = nums[numsLen - i -1];
    nums[numsLen - i -1] = temp;
}
</code></pre>
<p><strong>Ⅳ.插入数组元素</strong></p>
<p>插入以后，保证数组仍是有序的：</p>
<p>1、把新的数组元素放在数组的末尾，重新进行排序</p>
<p>2、找到第一个比插入数字大的数组元素位置（insertIndex），从后一个元素开始，将数字复制到后面一个元素中，将插入的数字赋值给下标为insertIndex的元素</p>
<pre class=" language-language-c++"><code class="language-language-c++">int inserIndex = numLen;
cout << "请输入要插入的数字：";
cin >> insertNum;
//1.找到第一个比插入数字大的位置insertIndex
{
    for(int i = 0; i < numLen; i++)
    {
        if(insertNum > num[i])
        {
            insertIndex = i;
            break;
        }
    }
}
//2.从后一个元素开始，将数字复制到后面一个元素当中
for(int i = numLen - 1; i >= insertIndex; i--)
{
    num[i+1] = num[i];
}
//3.将要插入的数字赋值给下标为insertNum的元素
num[insertIndex] = insertNum
//4.将数组的总长度+1
NumLen++;
</code></pre>
<p><strong>Ⅴ.删除数组元素</strong></p>
<pre class=" language-language-c++"><code class="language-language-c++">//1.找到要删除元素的下标
double deleteNum;
int deleteIndex = -1;
cout << "请输入要删除的数字：";
cin >> deleteNum;
for(int i = 0; i < numLen; i++)
{
    if(deletteNum == num[i])
    {
        deleteIndex = i;
        break;
    }
}
if(deleteIndex == -1)
{
    cout << "没有找到要删除的元素" << endl;
}
else
{
//2.从找到的下标开始，后面一个元素赋值到前面一个元素
for(int i = deleteIndex; i < numLen - 1; i++)
{
    num[i] = num[i+1];
}
//3.数组总长度-1
numLen--;
}
</code></pre>
<p><strong>5.二维数组</strong></p>
<p>语法：<code>datatype name[rowSize] [colSize]</code></p>
<p><strong>6.向量容器vector</strong></p>
<p>vector 是一个快速的动态分配内存的数组</p>
<p>大小可以动态扩展</p>
<p>向量容器特点：</p>
<ul>
<li>动态数组，可以在运行阶段设置长度</li>
<li>具有数组的快速索引方式</li>
<li>可以插入和删除元素</li>
</ul>
<p>定义和初始化：</p>
<ul>
<li>vector<double> vec1</double></li>
<li>vector<string> vec2(5)        [给5个储存空间]</string></li>
<li>vector<int> vec3(20,998)     [默认给20个元素，每个元素均为998]</int></li>
</ul>
<p>常用操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">移除容器中的所有数据</td>
</tr>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:center">判断容器是否为空</td>
</tr>
<tr>
<td style="text-align:center">size()</td>
<td style="text-align:center">返回容器中元素的个数</td>
</tr>
<tr>
<td style="text-align:center">[index]、at(index)</td>
<td style="text-align:center">返回索引为index的元素</td>
</tr>
<tr>
<td style="text-align:center">erase(pos)</td>
<td style="text-align:center">删除pos位置处的数据</td>
</tr>
<tr>
<td style="text-align:center">erase(beg,end)</td>
<td style="text-align:center">删除(bed,end)区间的数据</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回第一个元素</td>
</tr>
<tr>
<td style="text-align:center">insert(pos,elem)</td>
<td style="text-align:center">在pos位置处插入一个元素</td>
</tr>
<tr>
<td style="text-align:center">pop_back()</td>
<td style="text-align:center">删除最后一个元素</td>
</tr>
<tr>
<td style="text-align:center">push_back(elem)</td>
<td style="text-align:center">在容器末尾插入一个元素</td>
</tr>
<tr>
<td style="text-align:center">resize(num)</td>
<td style="text-align:center">重新设置容器大小</td>
</tr>
<tr>
<td style="text-align:center">begin()、end()</td>
<td style="text-align:center">返回容器首尾元素的迭代器</td>
</tr>
</tbody>
</table>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    vector<double> vecDouble = {98.5, 67.9, 43.6 32.9};
    //向数组中插入数字
    vecDouble.push_back(100.0);//在数组的尾部插入一个数字
    //遍历
    for(int i = 0; i < vecDouble.size(); i++)
    {
        cout << vecDouble[i] << endl;
    }
    //集合的通用遍历方法，使用迭代器iterator
    vector<double>::iterator it;//得到迭代器对象(实际上是指针对象)
    for(it = vecDouble.begin(); it != vecDouble.end(); ++it)
    {
        cout << *it << endl;
    }
    //排序
    sort(vecDouble.begin(), vecDouble.end());
    for(it = vecDouble.begin(); it != vecDouble.end(); ++it)
    {
        cout << *it << endl;
    }
    //逆序
    reverse(vecDouble.begin(), vecDouble.end());
    for(it = vecDouble.begin(); it != vecDouble.end(); ++it)
    {
        cout << *it << endl;
    }
}
</double></double></algorithm></vector></iostream></code></pre>
<p>向量容器使用场景：</p>
<ul>
<li>开始就知道元素的数量</li>
<li>对数据的索引和随机访问频繁</li>
<li>插入和删除大多数在尾端</li>
</ul>
<p><strong>数组总结</strong>：</p>
<ul>
<li>数组是可以在内存中连续储存多个元素的结构</li>
<li>数组中的所有元素必须属于相同的数据类型</li>
<li>数组必须先声明，然后才能使用</li>
<li>声明一个数组知识为该数组留出内存空间，并不会为其赋任何值</li>
<li>数组的元素可以通过数组下标访问</li>
<li>一维数组可用一个循环动态初始化，而二维数组可用嵌套循环动态初始化</li>
<li>二维数组可以看作是由一维数组的嵌套而构成的</li>
<li>vector容器提供了比数组更好地安全性和灵活性（array）</li>
</ul>
<h3 id="第五章-指针">第五章.指针</h3>
<p><strong>1.基本概念</strong></p>
<p>指针是<strong><em>一个值为内存地址的变量（或数据对象）</em></strong></p>
<p>内存地址一般使用16进制表示</p>
<p>CPU访问内存时需要的是地址，而不是变量名和函数名。</p>
<p>变量名和函数名只是地址的一种助记符，当源文件被编译和链接可执行程序后，它们都会被替换成地址。</p>
<p>编译和链接过程的一项重要任务就是找到这些名称对应的地址。</p>
<p><strong>2.基本用法</strong></p>
<p>语法：<code>数据类型 *指针变量名 = &amp;变量（取地址）；</code></p>
<p>如果不取地址，则被视为野指针，很危险！！！</p>
<p>例如：</p>
<ul>
<li><code>int * ptr_num = ...</code></li>
<li><code>char * ptr_name = ...</code></li>
<li><code>float * money_ptr = ...</code></li>
<li><code>double * p_price = ...</code></li>
</ul>
<p>注意：</p>
<p>Ⅰ.int* p的写法偏向于<strong>地址</strong>，即p就是一个地址变量，表示一个十六进制地址</p>
<p>Ⅱ.int <em>p的写法偏向于</em><em>值</em>*，*p是一个整型变量，能够表示一个整型值</p>
<p>Ⅲ.声明中的<em>号和使用中的</em>号含义完全不同</p>
<p>使用示例：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    double num = 1024.5;
    double* ptr_num = &num;
    cout <<　"ptr_num的值：" << ptr_num <<"\t"<< &num<< endl; 相同 cout "ptr_num指向空间的值是：" *ptr_num return 0; } < code></　"ptr_num的值："></iostream></code></pre>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    char ch = 'a';
    char * ptr_ch = &ch;
    cout << (void *)ptr_ch << "\t" << *ptr_ch << endl;
    //char型默认是字符串，void *可用于取char的地址
    return 0;
}
</iostream></code></pre>
<p><strong>3.空指针</strong></p>
<p>空指针（null pointer）：空指针不指向任何对象，在试图使用一个指针之前可以首先检查是否为空</p>
<p>用法：</p>
<blockquote>
<p><code>int *ptr1 = nullptr; //等价于 int *ptr1 = 0;</code></p>
<p>int *ptr2 = 0;            //直接将ptr2初始化为字面常量0</p>
<p>int *ptr3 = NULL;     //需要包含cstdlib头文件</p>
</blockquote>
<p>建议：初始化所有指针，并在可能的情况下，尽量等定义了对象之后再定义指向它的指针。</p>
<p><strong>4.void指针</strong></p>
<p>一种特殊的指针类型，可以存放任意对象的地址。</p>
<pre class=" language-language-c++"><code class="language-language-c++">double num = 3.14;
double* ptr_num1 = &num;
void* ptr_num2 = &num;
cout << boolalpha;
cout << (ptr_num1 == ptr_num2) << endl;  //true
</code></pre>
<p>注意：</p>
<p>①void*指针存放一个内存地址，地址指向的内容是什么类型不能确定</p>
<p>②void*类型指针一般用来：拿来和别的指针比较、作为函数的输入和输出；赋值给另一个void*指针</p>
<p><strong>指针小结</strong>：</p>
<ul>
<li>指针同样是一个变量，只不过该变量中存储的是另一个对象的内存地址</li>
<li>如果一个变量存储另一个对象的地址，则称该变量指向这个对象</li>
<li>指针变量可以赋值，指针的指向在程序执行中可以改变</li>
<li>指针p在执行中某时刻指向变量x，在另一时刻也可以指向变量y</li>
<li>指针一般是4个字节的存储空间</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>指针变量的命名规则和其他变量的命名规则一样</p>
</li>
<li>
<p>指针不能与现有变量同名</p>
</li>
<li>
<p>指针可为任何基本数据类型、数组和其他所有高级数据结构的地址</p>
</li>
<li>
<p>若地址已声明为指向某种类型数据的地址，则它不能用于存储其他类型数据的地址</p>
</li>
<li>
<p>应为指针指定一个地址后，才能在语句中使用指针</p>
</li>
</ul>
<p><strong>5.引用</strong></p>
<p>引用(reference)：为对象起了另外一个名字（引用即别名）</p>
<pre class=" language-language-c++"><code class="language-language-c++">int int_value = 1024;
//rerfValue指向int_value,是int_value的另一个名字
int& refValue = int_value;
</code></pre>
<p>错误：引用必须被初始化——<s>int&amp; redValue</s></p>
<p>注意：</p>
<p>①引用并非对象，只是为一个已经存在的对象起的别名</p>
<p>②引用只能绑定在对象上，不能与字面值或者某个表达式的计算结果绑在一起：<br>
<s>int &amp;ref_value = 10;</s></p>
<p>可以用：<code>const double&amp; ref = 100</code></p>
<p>③引用必须初始化，所以使用引用之前不需要测试其他有效性</p>
<p>④指向常量的引用是非法的</p>
<p>因此使用引用可能会比使用指针效率高。</p>
<p><strong><em>指针和引用之间的关系</em></strong>：</p>
<ul>
<li>引用对指针进行了简单封装，底层仍然是指针</li>
<li>获取引用地址时，编译器会进行内部转换</li>
</ul>
<p><strong><em>指针与数组之间的关系</em></strong>：</p>
<ul>
<li>存储在一块连续的内存空间中</li>
<li>数组名就是这块连续内存空间的首地址</li>
</ul>
<p><strong>6.指针运算</strong></p>
<p>指针的算数运算：</p>
<p>①指针的递增和递减（++、–）</p>
<p>注意：一个类型为T的指针的移动，以sizeof(T)为移动单位，即一个元素的字节大小</p>
<pre class=" language-language-c++"><code class="language-language-c++">int i;
double score[5] {98,97,65,43,76};
double* ptr_score;
ptr_score = score;
for(i = 0; i < 5; i++)
{
    cout << *ptr_score++ << endl;
}
</code></pre>
<p>②指针加上或减去某个整数值</p>
<pre class=" language-language-c++"><code class="language-language-c++">int i;
double score[5] {98,97,65,43,76};
double * ptr_score;
ptr_score = &score[1];
ptr_score += 2;
cout << *ptr_score << endl;
ptr_score -= 3;
cout << *ptr_score << endl;
</code></pre>
<p><strong><em>数组与指针小结</em></strong>：</p>
<ul>
<li>
<p>数组名就是这块连续内存单元的首地址</p>
</li>
<li>
<p>int num[50];     //num是数组名，也可以理解为数组的首地址</p>
</li>
<li>
<p>num的值与&amp;num[0]的值是相同的</p>
</li>
<li>
<p>数组第i+1个元素可表示为：</p>
<ul>
<li>第i+1个元素的地址：&amp;num[i+1] 或 num+i</li>
<li>第i+1个元素的值：num[i+1] 或 *(num+i+1) 同样尝试 *++ptr_num</li>
</ul>
</li>
<li>
<p>为指向数组的指针赋值：</p>
<ul>
<li>int * ptr_num = num; 或 int * ptr_num = &amp;num[0];</li>
</ul>
</li>
<li>
<p>指针变量可以指向数组元素</p>
<ul>
<li>int * ptr_num = &amp;num[4]; 或 int * ptr_num = num + 4;</li>
</ul>
</li>
</ul>
<p><strong>7.动态内存分配</strong></p>
<p>使用new分配内存：</p>
<ul>
<li>指针真正的用武之地：在运行阶段分配未命名的内存以储存值</li>
<li>在此情况下，只能通过指针来访问内存</li>
</ul>
<p>使用delete释放内存：</p>
<ul>
<li>与new配对使用</li>
<li>不要释放已经是释放的内存</li>
<li>不能释放声明变量分配的内存</li>
</ul>
<p>语法：</p>
<pre class=" language-language-c++"><code class="language-language-c++">//1.在运行阶段为一个int值分配未命名的内存
//2.使用指针来访问（指向）这个值（右-->左）
int* ptr_int = new int; // 分配4个字节的内存空间

delete ptr_int; // 释放由new分配的内存
</code></pre>
<p>注意：</p>
<p>不要创建两个指向同一块内存的指针，有可能误删除两次</p>
<pre class=" language-language-c++"><code class="language-language-c++">int* ptr = new int;
int* ptr1 = ptr;
delete ptr;
delete ptr1;
</code></pre>
<p>示例：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int main()
{
    int num[5];
    int * num1 = num;
    int* nums = new int[5];
    cout << sizeof(num) << '\t' << sizeof(nums) << endl; //20与4
    delete num1;
}
</iostream></code></pre>
<p><strong>动态分配数组</strong>：</p>
<p>使用new创建动态分配的数组：<code>int * intArray = new int[10];</code></p>
<p>new运算符返回第一个元素的地址</p>
<p>使用delete[]释放数组内存：<code>delete [] intArray;</code></p>
<p>[]释放整个数组</p>
<p>示例:</p>
<pre class=" language-language-c++"><code class="language-language-c++">int * ptr_int = new int;
short * ptr_short = new short[500];
delete ptr_int;
delete [] ptr_short;
</code></pre>
<p>关于new和delete使用的规则：</p>
<ul>
<li>不要使用delete释放不是new分配的内存</li>
<li>不要使用delete释放同一内存两次</li>
<li>如果使用new[]为数组分配内存，则对应delete[]释放内存</li>
<li>对空指针使用delete是安全的</li>
</ul>
<p><strong>8.程序的内存分配</strong></p>
<p><strong><em>栈区(stack)</em></strong>:</p>
<ul>
<li>由编译器自动分配释放，一般存放函数的参数值、局部变量的值等</li>
<li>操作方式类似数据结构中的栈——先进后出</li>
</ul>
<p><strong><em>堆区(heap)</em></strong>:</p>
<ul>
<li>一般由程序员分配释放，若程序不释放，程序结束时可能由操作系统回收</li>
<li>注意：与数据结构中的堆是两回事，分配方式类似链表</li>
</ul>
<p><strong><em>全局区</em></strong>：</p>
<ul>
<li>全局变量和静态变量是存储在一起的</li>
<li>结束后由系统释放</li>
</ul>
<p><strong><em>文字常量区</em></strong>：</p>
<ul>
<li>常量字符串就放在这里，程序结束由系统释放</li>
</ul>
<p><strong><em>程序代码区</em></strong>：</p>
<ul>
<li>存放函数体的二进制代码</li>
</ul>
<p>示例：</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;
int num1 = 1; //全局区
int main()
{
    int num = 90;  //存在栈区
    double d_nums[6] = {3,4,5,6};
    double * dArray = new double[10];  //一般：左边为栈区，右边为堆区
}
</iostream></code></pre>
<p><strong>9.二维数组与指针</strong></p>
<p>首地址：<code>&amp;a[0][0]</code></p>
<p>使用指针访问二维数组中的元素：</p>
<ul>
<li>*(a[1]+2)</li>
<li>*(*(a+1)+2)</li>
</ul>
<pre class=" language-language-c++"><code class="language-language-c++">int (*p)[4] = new int[4][4];//降维处理
//sizeof(p) = 4
</code></pre>
<p><strong>指针小结</strong></p>
<p>①指针是一个<strong>变量</strong>，存储<strong>另一个变量（对象）的内存地址</strong></p>
<p>②指针的声明由<strong>基本类型、星号（*）和变量名</strong>组成</p>
<p>③为指针赋值，赋值运算符右侧必须是<strong>一个地址</strong></p>
<ul>
<li>如果是普通变量需要在前面加一个取地址运算符 &amp;</li>
<li>如果是另一个指针或者是一个数组，不需要加&amp;运算符</li>
</ul>
<p>④运算符 * 用于返回指针指向的内存地址中存储的值</p>
<p>⑤使用指针访问一维数组和二维数组的元素（降维处理）</p>
<p>⑥指针一般不进行算数运算，因为地址相加相减没有任何意义，但是指针可以进行自加和自减运算，实际上是存储地址的移动：</p>
<ul>
<li>int * p1-- p2++  ： 每次移动4个字节</li>
<li>double * p1-- p2++ ： 每次移动8个字节</li>
</ul>
<p></p><h2 style="text-align:center">C++进阶</h2><p></p>
<h3 id="一-函数">一.函数</h3>
<pre class="mermaid">graph LR;
A[内置函数] --> B(STL和Boost C++);
A --> C(自定义函数);</pre>
<pre class="mermaid">graph LR;
A[C++标准函数] --> B(输入/输出)
A --> C(数值)
A --> D(诊断)
A --> E(通用工具)
A --> F(国际化)
A --> G(语言支持)</pre>
<pre class="mermaid">graph LR;
A[STL] --> B[字符串]
A --> C[算法]
A --> D[容器]
C --> E[迭代器]
D --> E[迭代器]</pre>
<p>函数“三要素”：</p>
<ul>
<li>返回值类型</li>
<li>函数名</li>
<li>参数列表</li>
</ul>
<pre class=" language-language-c"><code class="language-language-c">return_type functionName(parameterList)
{
    //函数体
}
</code></pre>
<p>书写自定义函数：</p>
<ol>
<li>
<p>函数原型与函数定义的头部类似，最后以分号结束</p>
</li>
<li>
<p>函数原型中的参数名称可以省略，只写参数类型</p>
</li>
<li>
<p>C++中返回值类型不能是数组，但可以是其他任何类型（可以将数组作为结构或对象组成部分返回）</p>
</li>
</ol>
<p>示例：</p>
<pre class=" language-language-c++"><code class="language-language-c++"># include <iostream>
using namespace std;

int sum(int, int); //函数原型
int main()
{
    //函数调用
    int result = sum(5,3);
    cout << "结果为：" << result << endl;
    return 0;
}
//函数定义
int sum(int sum1, int sum2)
{
    //函数实现代码
    int result = num1 + num2;
    return result;
}
</iostream></code></pre>
<p><strong><em>按值传递</em></strong>：</p>
<p>给函数传递变元（参数）时，变元（参数）值不会直接传递给函数，而是先制作变元（参数）值得副本，储存在栈上，再使用这个副本可用于函数，而不是使用初始值。</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;

void changge(int num)
{
    num++;
}

int main()
{
    int num = 10;
    change(num);         //传的是地址值
    cout << num << endl; //打印值仍然是10
}
</iostream></code></pre>
<p>注意：</p>
<p>1、数组作为函数实参时，只传递<strong>数组的地址（首地址）</strong>，并不传递整个数组的空间</p>
<p>2、当用数组名作为实参调用函数时，数组首地址指针就被传递到函数中</p>
<p><strong>函数地址</strong></p>
<p>函数的地址是储存其机器语言代码的内存开始地址</p>
<p>好处：可以在不同的时间使用不同的函数</p>
<p>函数指针的声明：</p>
<pre class=" language-language-c++"><code class="language-language-c++">//函数原型：
double sum(double,double);
//函数指针声明：
double (*ptrSum)(double, double)
</code></pre>
<p>注意：</p>
<p>1、该语句声明了一个指针ptrSum,指向一个函数</p>
<p>2、double *ptrSum(double, double)不是函数指针，而是声明了一个函数ptrSum，返回double *类型</p>
<p>3、C++11中可以使用auto ptrFunc = …;自动推断类型（自动类型推断需要确保变量的类型与初值类型一致）</p>
<p>4、可以使用typedef简化声明：</p>
<pre><code>typedef double (*ptrCalc)(double double)

ptrCalc ptrFunc;
</code></pre>
<p><strong>内联（inline）函数</strong>：</p>
<p>内联函数是C++为提高程序运行速度所做的一项改进，与常规函数区别不在于编写方式，而在于<strong>被调用时的运行机制不同</strong>。</p>
<p>编译器使用函数代码替换函数调用。</p>
<p>使用建议：</p>
<p>1、如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分；</p>
<p>2、如果代码执行时间很短，内联调用就可以节省大部分时间。</p>
<p>使用内联特性（采取其一）：</p>
<ol>
<li>在函数声明前加关键字inline</li>
<li>在函数定义前加关键字inline</li>
</ol>
<p><strong>引用</strong>：</p>
<p>引用(reference)：</p>
<p>为对象起了另外一个名字（引用即别名）。</p>
<p>注意：</p>
<p>1、引用并非对象，只是为一个已经存在的对象起的别名</p>
<p>2、引用更接近于const指针，一旦与某个变量关系关联起来，就将一直效忠于它</p>
<p>3、将引用变量用作参数时，函数将使用原始数据，而非副本</p>
<p>4、当数据所占用内存比较大时，建议使用引用参数</p>
<p>5、引用参数中使用const可以避免参数被无意修改</p>
<p>6、引用参数建议尽可能使用const</p>
<p>返回引用：</p>
<p>函数返回引用类型：</p>
<p>1、不要返回局部变量的引用</p>
<p>2、函数可以不返回值，默认返回传入的引用对象本身</p>
<p>3、返回引用时，要求函数参数中包含被返回的引用对象</p>
<p>使用引用参数：</p>
<p>1、能够修改调用函数中的数据对象</p>
<p>2、数据对象较大时传递引用可以提高程序的运行效率</p>
<p>3、函数中不需要修改传递的参数：</p>
<ul>
<li>如果数据对象很小，建议使用传递</li>
<li>传递数组只能使用指针，并使用const关键字</li>
<li>较大的对象则使用const指针或引用，以提高程序的效率</li>
</ul>
<p>4、函数中需要修改传递的参数：</p>
<ul>
<li>数据对对象是基本类型或结构时，可以使用指针或引用（基本类型建议使用指针）</li>
<li>数据对象是数组时只能使用指针</li>
<li>数据对象是类对象时，要求使用引用</li>
</ul>
<p>使用默认参数：</p>
<p>1、默认值可以在函数原型或定义中给出，不能在这两个位置同时出现</p>
<p>2、对于带参数列表的函数，必须从右向左添加默认值</p>
<p><strong>函数重载(overloading)</strong></p>
<ul>
<li>指可以有多个同名的函数</li>
<li>函数名相同，参数列表不同（特征标不同）</li>
<li>调用匹配函数时，不区分const和非const变量</li>
</ul>
<p><strong>函数模板（Function Template）</strong></p>
<p>函数模板，实际上就是建立一个<strong>通用函数</strong></p>
<ul>
<li>函数定义时不指定具体的数据类型（使用虚拟类型代替）</li>
<li>函数被调用时编译器根据实参反推数据类型——类型的参数化</li>
</ul>
<pre class=" language-language-c++"><code class="language-language-c++">//模板头与函数声明或定义永远是不可分割的整体
template <typename 类型参数1, typename 类型参数2, ...>
返回值类型 函数名(形参列表)
{
    //在函数体中可以使用类型参数
}
</typename></code></pre>
<p>C++学习到此结束💥 💥 💥</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/04/29/C++/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/04/29/C++/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":-45,"vOffset":-20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":-45,"vOffset":-20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>



 	
</html>
